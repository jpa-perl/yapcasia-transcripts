　はい、時間になりました。皆さんおはようございます。朝イチのセッション、大ホールですが、皆さん集まっていただいてありがとうございます。Mojoliciousで作る、これは「モジョリシャス」って読むんですけども、「Mojoliciousで作るWebアプリ入門」という内容で始めたいと思います。よろしくお願いします。
　
　自己紹介なんですが、本名は和田裕介（ワダ・ユウスケ）、「ユースケ」と呼ばれてます。ワディットとオモロキという会社に所属しています。これまでいろいろなものを作ってきたんですけども、今メインワークとしてやっているのは、bokete（ボケテ）っていうアプリのWebサービスのバックエンドです。これも実はMojoliciousで作られています。ある程度の規模のアプリでも使えます。 
　
　で、最初の問いかけです。あとこの変な人が出てきますけども、これはイメージ画像なのであんまり気にしないでください。
　
　Perlは、結構大規模Webサービスで使われているみたいな印象があります。まさにこのバックパネルのDeNAさん、livedoorさんは旧体制のときからPerlを使っていますし、ミクシィさんもそうですね。そういったサイトのロゴを見ると、あーあそこは大きなサービスではPerlを使ってるねっていうのが見受けられます。が、です。みなさんの中にもいるかもしれないんですけども、初心者の人に向けたアプリ入門の資料とか本とか、ある程度まとまっているWebサイトは少ないんじゃないかなと思っていました。
　
　あえて去年を振り返ると、まったく同じ条件で土曜日の朝イチでトークをさせてもらったんですけども、「新しいを生み出すためのWeb開発とその周辺」ということで、若干似たようなテーマでやったんです。ただ内容は結構違ってて、Perlでいろいろアプリを作るときに、大切なのは、「どうやって作るか」よりも「まずは何を作るか」で、”What”の部分が大切だなということで、企画の作り方みたいなことを、Perlとは関係ない文脈で話したりもしました。それで、別に続編っていう立ち位置ではないんですけども、連続性があると考えると、何を作るかはわかったとすると、今回の主題は、そのための実装のきっかけなのかなあと思います。なので、「Webアプリを作りたい」「アイデアはあるんだけど、きっかけがないなあ」っていう方とか、Webアプリケーションフレームワークを、頭文字をとってWAF（ワフ）って呼んでるんですけども、このWAFについて知りたい方、あとはMojoliciousを使ったアプリについて知りたい方が対象オーディエンスですのでよろしくお願いします。
　
　まず、僕らが開発のときとかに当たり前に使っている「概念」とか「実装」などのキーワードって、実は周辺の方には意味がわからないこともあるし、そもそもどういうキーワードがあるのかがわからないというケースも結構あると思っています。ですので、それは時間内で噛み砕いて使うことにして、あとは資料をアップロードするので、それをGoogleやCPANで検索できれば復習できるかなと思います。チュートリアル的な意味合いも込めて、こういう方針を立てています。アジェンダとしては、とある占いアプリを題材にして解説して、それをどういうふうに拡張していくかということを、Mojoliciousを使って考えていこうという形です。
　
　はい。じゃあ占いアプリってどんなものかというと、超簡単です。名前を入力すると占い結果を出す。結果はまず3種類として、もうテキストで決め打ちにします。「良いことがあるでしょう」「出会いがあるかも？」「不幸になります」で、大吉、末吉、凶みたいな感じの、ホントに3種類だけです。そして、入力された名前に対して必ず同じ結果が返るっていうようなことをやろうと思っています。つまりアルファベットで「yusukebe」って入れたら、必ず「出会いがあるかも？」っていうふうに出てきます。そこを、例えばPerl入学式で著名なパピックスさんだとすると、papixって入れると「良いことが起こるでしょう」とか。人の名前を変えるともちろん結果は変わるけども、同じ名前であれば結果は変わらないっていうような仕様にします。突然出てきたんですが、それを実装するときに、ちょっと広い意味でのハッシュ関数を実装しなくてはいけません。もうちょっと短く書けるんですけども、実装構造はこの例でほぼ完璧です。何をやってるかというと、文字列を受け取ったら、それをそれぞれ数値に直します。で、数値に対してある固定的な値で割って、その余りが結果となります。つまり、yusukebeという文字列があった場合は、必ず余りの結果が0になるっていうようなロジック、つまり仕組みを実装してるので、これを利用すると必ず同じ結果が出すことができます。ハッシュっていうと、Perlのデータ構造のスカラ、配列、ハッシュと混同しがちですが、そのハッシュとは違うまったく別ものなので、これは注意してください。これはスクリプトで実現することもできて、.plのスクリプト言語で書くと、perl uranai.pl yusukebeとなります。yusukebeというのが引数になっていて、そうすると「出会いがあるかも？」という結果が出てきます。なので、スクリプトレベルの占いアプリをWebアプリにしていくとどうなっていくかと考えると、これをもうちょっと発展させると、〓ケンタ〓のなんとか診断メーカーみたいな、「あなたはなんとかです」「なんとかさんの結果はこんなんです」みたいな、やたらとバズっていて、そこのサイトに行くとたぶん広告が貼ってあって、これ簡単なのに結構儲かるなというような仕組みがあるんですけども、それにちょっと近いものができるかもしれません。
　
 【1.Webアプリケーションとフレームワーク】

　はい。本題に入ります。Webアプリケーションを作るときに、ちょっと定義し直します。これは、具体的に言うか抽象的に言うかとか、方向性や人によってだいぶ定義が違うと思うんですけども、ここではこうします。「Webが誰かと特徴的なインタラクションをする場合」、Webアプリケーションと呼ぼうというふうに考えております。例えば占いアプリの場合だと、ユーザーがいて、その人がブラウザを経由して自分や人の名前を入れます。それに対してWebアプリケーションが占いの結果を出力するので、それを見るというこの矢印のやり取りが、Webアプリケーションにとってはリクエストとレスポンスという形になるんですけども、こういうインタラクションが起こる場合にWebのアプリケーションだと言えるということになります。今の占いアプリとかもJavaScriptだけで実装できるんですけども、その場合もWebアプリケーションなんじゃないのっていうのが僕の考えです。あとはWebアプリケーション自体が外部のWeb APIとかミドルウェアと連携する、そこがインタラクションだったらアプリケーションだし、例えばユーザー側も、PCブラウザだけじゃなくて、最近だとスマホのアプリでWeb APIを叩いて結果を取得して何かをするみたいなこともよくあるので、Web API自体もWebアプリケーションだということができるんじゃないかなと思います。
　
　Web Application Frameworkというのがありまして、今回もYAPCでもいろいろトークされるんですけれども、通称WAF（ワフ）っていうふうに呼ばれたりもしますね。ただ、PerlのコンテキストというかPerlの界隈では結構WAFと呼ばれてるんですけども、例えばRuby（ルビー）とかPython（パイソン）のコンテキストでWAFなんて言うと、「は？」という反応をされるかもしれなくて、どれだけそういう略語が浸透してるかわかんないですね。ただWebアプリケーション・フレームワークの筆頭といえば、世の中的にはたぶんRuby on Railsなんですね。別にdisる必要はない。これはまあ簡単に言うと、Webアプリケーションを作るための土壌ですね。MVCモデルに基づく場合が多いとよく言われています。じゃあMVCって何だ？ってことなんですけども、まあModel、View、Controllerというふうに区分けしたものでWebアプリケーションを動かすことがMVCだよということで、頭文字から取っています。
　
　ここでちょっと、MVCである意味ってどういうことなんだっていうことについて深掘りしたいと思います。これはたぶん結構重要です。MVC以前というのがあって、単に汚いコードを載せてるだけなんですが、これは実はGoogleでCGIとかで検索すると結構トップに出てくるこういうコードがあります。いわゆるCGIを呼ぶCGIなんですけども、なんかこれ気持ち悪くないですかね？　1つのところにいろいろ混じっているのがイケてないんです。たとえばヘッダーの出力とか、ロジック、先ほどの占いアプリの場合だとハッシュ関数を使った処理の部分ですね、その処理の部分とかも混じってたりとか、HTMLの描画とかが、結構な量をprint文でやっているんですね。これだとなんだか気持ち悪いし、HTMLが肥大化するので、print文で全部賄えるのかということも出てきます。CGI自体は配信方法のひとつなんで、CGIを良くないとか馬鹿にするっていうことはまったくしないです。CGIはCGIでいいんですけども、CGIが流行っていた時代に、CGI的に書かれた良くないプログラムというのがあって、それを見るとなんかイケてないよねということです。じゃあどうするとそれが良くなるかっていう話なんですけども、まずその占いアプリをCGI的に書くとこういうふうになります。これでも結構まとまってるほうですね。ただどうしても、print文でHTMLに出力するのはちょっとダサいですよね。もっと複雑なHTMLになったり、分岐があったりしたときにどうなるかと考えると、思ったより柔軟ではないんですね。で、これはフレームワークを使わない場合です。テンプレートエンジンというものを使って、今回はテキスト内蔵テンプレートを使ってるんですけども、HTMLを書いて、その中で特殊な記号で、ここに例えば占いの結果を出すみたいなテンプレートをHTML的に書くことによって、だいぶ見通しが良くなるんですね。これは、データセクション以下に書いて、それを呼び出すようにしてるんです。コードは結構長くなってるんですが、見通しは良くなっています。さらにテンプレート自体を別のファイルに分けることもできて、そうするとメンテナンス性も向上しますし、ヘッダー部分とかフッター部分を共通で使うと、再利用性の向上が図れます。また、冗長になった部分は、今後紹介するフレームワークが吸収してくれるので、あまり冗長になることもありません。で、MVCで考えてみますが、今回はビュー、見た目の部分をちょっとクールにしてみました。混在している固まりを役割で分けて、そこの感覚を理解すれば、たぶん冗長にならないと思います。開発効率が上がるという感じですね。言葉としてあるかどうかはわかんないんですが、分けることはよく分かることだと思っています。役割ごとに分けすぎるのもよくないんですね。分けることで分かる。だから入門もしやすいし、最初は汚いコードで書いてもいいですけども、徐々に入っていけるんじゃないかなと思います。あと、MVCに限らず、最近のPerlのフレームワークでよく行われている切り分け方なんですけども、Router、Controller、Model／Logic、DB層もしくはOR Mapper層、View、先ほどのテンプレートのところにはこういうキーワードがあります。こういうふうに役割を分けることが、フレームワーク的思考ではないかなと思っています。で、今のコンポーネントを処理の流れとして見せると、最初にリクエスト・アクセスがきたら、Routerと呼ばれるところがURLのpathと、HTTPのGETかPOSTかっていうメソッドによってディスパッチをしてコントローラというところに行って、コントローラが処理ロジックを呼び出して、DBが引っかかったら通信をして、結果をコントローラに返します。で、先ほどのようにテンプレートなどを使って、HTMLとかJSONとか、XMLの場合もありますけれども、何かの形でレスポンスを返すという流れになっています。
　
　こういうものを実現するためのPerlのWAF達を出せるだけ出してみました。最近だと、Amon2（アモンツー）、今回トークでも結構多いですね。Amon2、tokuhiromのAmon2もいいと思います。僕はニュートラルな状態で言いますけども、あとは今回紹介するMojolicious。でCatalyst（カタリスト）っていうのは、日本のコンテキストだと結構異例な感じで扱われていて、5年くらい前はみんな使って、使えるぞ、すげーっていう感じだったんですけども、ある日突然、いやこれちょっと重厚すぎないかっていうふうな感じでちょっと切られて、日本では最近あんまり使ってる人はいないですね。ただアメリカの文脈とかほかの海外の文脈だと未だにCatalystは使われているので、そこに変な偏見を持たないでCatalystっていうのも向いてみるといいかもしれないです。最後に自作WAFって書いてありますけども、MVCみたいな、先ほどのコンポーネントの組み合わせを実現するモジュールって非常に揃っていて、Plack（プラック）っていうユーティリティツールのPlack::Request（プラックリクエスト）とか、ルーティングをするRouter::Simple（ルーターシンプル）とか、ビューを吐き出すText::Xslate（テキストエクスレイト）とか、この辺を使うと、結構WAFって自分で作れちゃうんですね。これがすっごい楽しいんです。ただ、上位のアプリを作って、しかもその土台のWAFを作るようになると、考え方を変えなくちゃいけないので、結構きついんですね。なので、勉強用にとか、ちょっと休日があって、何か作ろうかなっていうときに、車輪の再発明になりますが、それは大いに歓迎すべきことかなと思います。ただ、とりあえずWAFを使いましょう。

【2.Mojoliciousの紹介】

　で、もちろんMojoliciousの紹介です。モジョリシャース、イエーイ！みたいになって。俗に言う軽量WAFの一種です。これも軽量ってつけてるのは、Catalystっていうフレームワークが、別に中身は知らなくてもいいんですけども、重厚だと呼ばれているから、それに対して軽量というふうにアンチテーゼとして言われているフシはあります。最新バージョンは4.35じゃなくて、たぶん4.36とかになっているはずです。リリースはすごく早い。作者がセバスチャン・リーデル氏で、実はこの人はCatalystを作った人です。あと、個人的には、このアイコンがすごく気取ってて、ちょっと最初抵抗感があったんですけど、ドキュメントを何回も見ると見慣れます。
　
　特徴なんですけども、MVCで考えるとVとCだけサポートしてます。ルーティング、コントローラの部分を担当していて、あとはmojoテンプレートっていうのに準じるとテンプレートが書けます。それだけサポートしてて、モデルは勝手にやってねっていう方針です。これは逆に結構良くて、モデルとかロジック、占いで言うとハッシュ関数を使って占いの処理をするところっていうのはWebから切り離して考えることができるんで、そうするとほかのコマンドラインインターフェイスから使ったりすることもできる。だから切り離すべきだなあと僕は思っています。特徴その2なんですけども、ノット・フルスタック、バット・フルスタック。なんで否定して肯定してるのみたいな感じで、何言ってるのコイツって言われるかもしれないんですけども、例えばRuby on Railsだと、データベースを扱う、それこそモデルを含めてすべてこれ1つでできるよねっていう謳い文句で、これだけ使っていればWebアプリケーションが全部できちゃうっていう機能的な意味でフルスタックと呼ばれています。それに対して、Mojoliciousはモデルをサポートしないから、そういう意味ではフルスタックとは言えないんです。ですが実装の部分を見ると、HTTPのリクエストオブジェクトとか、ユーザエージェント、LWP::UserAgentみたいなユーザエージェントまでMojolicious内で使うライブラリがすべて自作されています。なので、そういう意味では実装面ではフルスタックと言えるんです。これだけだと何を言ってるかわかんないっていう雰囲気だと思いますけども、つまりPerlのコアモジュールの外のライブラリに依存してないんです。ですからこれだけたくさんあるんですけども。モジョのPageを見ると、いろんなものを自作してるんですね。その代わり、他のものも使ってないんです。だから簡単に言うと、CPANM Mojoliciousエンターってやると、外部のモジュールを取ってこないで、このMojoliciousだけが入ります。今回紹介するようなちょっとしたアプリケーションでしたら、Mojoliciousを入れるだけで動くという意味では、ポータビリティがすごく楽なフレームワークです。ということで、Mojoliciousなら一発なんですね。その他の特徴としては、アップデートが頻繁です。例えばrender_jsonっていうJSONを吐くメソッドがあったんですけど、実はこれが廃止されたんですね。ただ、依存がまったくないので、Mojoliciousだけ追っていれば結構対応できます。あと、Mojolicious::Liteっていうのをこれから説明するんですけども、ファイル1個だけでWebアプリケーションができるっていうのが特徴のライトモードっていうのがあります。工夫すればCGIでも動作可能で、実際僕も仕事でそれをやったことがあります。あと、開発用のサーバーとしてmorbo、本番用としてhypnotoadというのがありますが、実はPSGIに互換しているので、PlackっていうPSGIに対応するアプリケーションツールのモジュールを使うと、plackupとか、Starmanというサーバーとか、Starletのサーバーとかで動かすことも可能です。実際僕もplackupで開発をして、本番環境ではStarmanで動かしてます。Mojolicious Liteみたいに小さなアプリから、スケールするような大きなアプリまで対応してて、一言で言うと徐々に学べるフレームワークかなあと思います。Mojolicious Liteを使って、今度はMojoliciousのMojoliciousを使って、CPANモジュールを組み合わせていくみたいな感じで、だんだんとステップアップしていくことができるんじゃないかなと思っています。
　
【3.Mojolicious Liteを使ってみよう】

　ということで、Mojolicious Liteを使ってみましょう。Mojoliciousをインストールすると、mojoコマンドっていうのが入るので、それによってスケルトンという雛形を作ることできます。で、それをちょこちょこいじると、ハローワールドみたいなのができますね。まあ単にハローモジョを表示させるだけなんですけども、これを見ると結構ポイントがあって、「get '/'」（ゲット・スラ）って先頭に書いてあるところがあります。これがスラッシュですね。要は、yusukebe.comのスラッシュみたいなところにアクセスして、した場合どうするかっていうことを定義しています。これがルーティングっていう意味合いにあたります。で、サブルーチンのこの「sub」の中の部分があるんですけど、ここが、Controllerに値してて、$selfを取ってきて、その$selfにいろいろやるんですけども、stashのmessageっていうところに、Hello Mojo! というテキストを入れます。これをテンプレートに渡したいっていうのをこうやって書きます。レンダリングするときに、データセクション以下に書いたテンプレートがレンダリングされるんですけども、messageっていう変数名で渡してるので、$messageでここで展開されて、実際の描画はここにHello Mojo!っていうふうに入るっていうのが、一番簡単なMojolicious Liteのアプリです。立ち上げ方は、morboを使ってもいいし、plackupでも大丈夫です。ここから学べることは結構あって、さっき説明した通りなんですが、あとPOSTメソッド、「/entry」にPOSTを投げたときはこういうふうに書けるし、例えば「/entry/123456」みたいなブログみたいな仕組みがあって、エントリーナンバーで管理するときに、その1234っていうところをキャプチャすることもできます。あとは、テンプレートにメッセージやデータを渡すときにはstashを使って変数で展開させると、テンプレートの中で展開されて、Hello Mojo!というのが出たりって感じですね。
　
　もちろん占いアプリも作れます。時間がないけど、ショートライブコーディングをやってみます。これが占いの、先ほど言った通りのコマンドラインに出すやつですね。なので、こうやると、yusukebeが引数になってプログラムに渡るので、「出会いがあるかも」と出ます。これが占いです。先ほど言った通りハッシュ関数を通しているので、いくらyusukebeって入れても、この結果になって、で、例えばpapixとかってやると、「良いことが起こるでしょう」と。良かったですね。で最後にdankogaiって入れます。入れると「不幸になります」（笑）。これは本当にそういう●に従ってそうなったんです。コードはこの通りで、リストの中に入れてます。ここがハッシュ関数の部分ですね。じゃあ作ります。はあ、時間がない。generate liteup uranai mojo.pl。これで作れるんですよ。で、編集します。uranai mojo。これがデフォルトで、立ち上げましょうと。立ち上げるときにplackupします。引数でこうやって指定することでファイルが書き換わっても自動的に再起動するんで、5001番コードで立ち上げます。あれ、なんかおかしいな。えーと、あ、そうだ、ファイルを指定しなかった。ファイルを指定すると自動的にpsgiが入ってくれます。よし、ローカルホスト、エイってやると、出てきましたね。これがデフォルトの状態です。で、デフォルトとかなんか嫌なんで、変えます。全部消しちゃおう。単にテンプレートでハローヤプシーってやるとどうなるかというと、変わってます。これ、ある程度立派なWebアプリです。で、例えばメッセージを、「ヤプシー、カモン」ってやるじゃないですか。メッセージが変数に入るので、ここで展開したければ、メッセージって打つと出てきます。これがstashで、コントローラから変数を渡します。

　いよいよ占いアプリなんですけども、ちょっと怪しいタイトルをつけますね。で、フォームで入力してもらうんで、フォームタグを使うんですけども、そのときにフォームのアクションの先がresultっていうふうに仮定します。テキスト、ネーム、イコール、ネームっていうパラメータで飛ばしてもらいます。つまり、ここまで書いたらサブミットボタンを作らなくちゃいけなくなります。そうするとこういうふうになって、一番やりたいのは「yusukebe」ってやると結果が出ることなんですけど、それが実装されてないと怒られます。なので、ここで実装します。ネームでパラメータを取るので、ここでネームってやっちゃえば、そのままネームと渡すこともできます。それと、レンダリングするパスはもう1個テンプレートを作らなくちゃいけないんですが、resultっていうテンプレートで、こうなります。名前を表示したいので、名前を展開します。エラー出てないね。大丈夫かな。出た。ちゃんとここに、フォームに入力したのが出ました。じゃあ、この名前で占ってみます。占ってみるのにいちいちロジックを書くのは面倒なので、ここからコピペします。コピペして、しかも名前、変数名も同じなので、このまま動きます。で、このメッセージっていうのに占いの結果が入るので、メッセージに渡します。さらに、ここで占いの結果はメッセージだよねーっていうふうにやっていくと、出る、かな？ 出たらちょっと拍手してください。出た。（拍手）2度入れても、もちろん同じ結果になります。さっきと同じ通り、同じロジックなので、こうなります。すみません（笑）。ライブコーディングは以上です。
　
　で、何となくお分かりになったと思うんですけども、コントローラ内での操作はダラーセルフ（$self）でもらったやつで、全部こうなってます。なので、キー（key）っていうパラメータの値を取りたかったら、セルフ・リック・パラム・キーで取れます。あとはテンプレートをレンダリングしたかったらレンダーリストを使ったりとか、説明はしませんでしたけども、redirectとか302 redirectとかも、redirect_toっていうメソッドがあります。これはMojoliciousコントローラっていうライブラリのモジュールそのものなので、そのドキュメントを読めば分かります。テンプレートは、今のmojoテンプレートに準ずるテンプレートの書き方で書いたんですね。これはパーリッシュテンプレーツって書いてあって、Perlが書けるんですよ。なので、配列リファレンスを渡して、コードでエントリーを回して、エントリーズっていう変数を回して、そこのタイトルを表示するってことを結構やったりします。これはPerlなので、デザイナーさんに渡すのが難しかったりとかするかもしれないんですけれども、まず1人とかでやる分にはこれで良かったりします。この辺のmojoテンプレートとか、Mojoliciousプラグインデフォルトヘルパーとかのドキュメントを見ると、結構やり方がわかります。

　では、もうちょっと拡張したいとき、例えば画像を出したいときはどうすればいいのかというと、public/っていうディレクトリを作ってその中に画像を置いて、/css, /stylesheetというふうに指定すると自動的に読み込んでくれます。あと、テンプレートファイルはデータセクション以下に書いていましたけど、それをファイルに分割してtemplates/っていうディレクトリに入れると分けることもできますので、この辺は結構便利ですね。
　
【4.より実践的なアプリへ】

　で、より実践的なアプリということで、ひと回り大きくなる場合があります。そこでLiteじゃないMojoliciousでアプリを作ると、モジュールをいい感じに作って分けることができます。より分かりやすくなる。推奨するのは mojo generate app MyAppみたいな感じのコマンドを叩く感じなんですけども、MyAppっていうようなネームスペースじゃなくて、MyApp::Webっていうようなネームスペースで作っています。つまり、占いのWebの場合だと、Uranaiっていうので作るんじゃなくて、Uranai::Webっていうふうに指定します。どうしてかというと、Uranaiっていうネームスペースで作ると、Uranaiっていうモジュール自体がWebをサポートしなくちゃいけなくなってしまうからです。Uranai::のModelとかLogicとかっていうようなモデル層をこういうネームスペースで作りたかったり、コマンドラインインターフェイスそのもののモジュールをUranai::CLIみたいな感じのネームスペースで作りたかったりするときにちょっと困るし、Uranaiっていうアプリケーション自体が単にWebの層だけじゃないっていう意味では、こういう作り方をします。ざっくり言うと、結果的にだいたいlibディレクトリの下はこんな感じなので、一番上からDBレイヤー、使う場合はDBレイヤー、例えばTengっていうORマッパーのモジュールを使う場合は、こういうふうになったりします。あるいはビジネスロジックを扱うようなところですね。で、WebのところはWebレイヤーとコントローラと、あとルーターってところですね。
　
　じゃあLiteから移行するときはどうすればいいのって話なんですけども、概念的にはやってることはほぼ同じなんで、ファイルを分けるだけで移行することができると思います。web/subっていうルーティンのところは、lib/Uranai/Web.pmでルーターの定義をすることができるので、そこに移行させます。コントローラの部分は、lib/Uranai/Web/Controllerとか、RootとかEntryとか、こういうファイルで作って、コントローラを書いていきます。これはMojoliciousコントローラのどちらでも継承した形になっているので、Liteでも普通のMojoliciousアプリでも、ほぼ同じで書ける。テンプレートの部分も、別ファイルに分けるだけでmojoテンプレートっていう文法に沿ったテンプレートの書き方でいいんです。すんなり移行できるということですね。
　
　占いアプリを実装してみると、実装方針として、もうちょっとカッコ良くしようというところで、占いのロジック、ハッシュ関数があるところをモデルとして切り出すといいんじゃないかなーという感じですね。MouseっていうClassビルダーを使って書くと、ベタ書きですけどこうなるんです。こうすると何がいいかっていうと、このコードは実際動くので、CLI、コマンドラインインターフェイスから単体で動かすことができます。なので、面白いロジックがあったらそれをWebでも活用できるし、コマンドラインでも活用できるっていう、そういう良さがあるし、普段はテストの話はあんまりしないんですけども、単体でモデルだけでテストができることがすごく大きいポイントだったりします。ただ、ここはコントローラなんかだと愚直に呼んでますけども、useして、モデルをどういうふうにロードするかっていうのは議論の余地があるかなーと思います。とりあえずモデルを書いて、それを単体でテストして、ルーターのところとコントローラを書いて、テンプレートを書いて、テンプレートのところがHTMLとかジェイソンとか入ってくるんで、けっこう大変かもしれないんですけども、やっていきます。さっきみたいにテストサーバーに記録して、自動的にファイルの先が変わる度に再起動するようにさせておくと便利だったりするんですけども、ブラウザで確認するということの繰り返しですね。赤字が確認するところです。
　
【5.CPANモジュールとの組み合わせと工夫】

　ただ、CPANモジュールを使わないとMojoliciousでは足りない部分があるので、Mojoliciousをベースとして、いろいろORマッパーとかフォームバリエイターとかを使っていきます。レゴのブロックみたいですね。ちょっとだけ紹介しますけども、例えばFormValidator::Liteみたいなものは、そのままわりとカジュアルに使えるかなと思います。フォームバリエイターとはどういうことかというと、入力値の妥当性をチェックするためのモジュール集のことです。モジュールネーム空間ですね。例えば、メールアドレスがメールアドレスっぽいかっていうのを判定したりします。@がついてどんな感じでとか、郵便番号は7桁の半角数字だよーとか、文字数、例えばツィッターのつぶやきは140文字以内だよねーとか。そういうのをチェックするのにいちいちルールを書いてると、ちょっと大変なんです。なのでそれを簡略化して、名前は、ネームのパラメータは必須で、メールのパラメータはEメール形式でみたいなことをルール付けして、適切にエラーが出ているかどうか、その場合エラーメッセージを出すなどということをやってくれます。で、Tengを使うと、ORマッパーで結構簡単にデータベースを触ることができます。例えば3つの選択肢があったのをどんどん増やしたりできるんです。それをやるのにデータベースを作って、Tengのスキーマを作ってモデル化して、簡単なテストを書いて、コントローラーを呼び出して、ビューを変更して、できたー！ みたいな感じで、どんどん拡張して作ることができます。

　その他、僕が実践で使ってるモジュールです。これは全部説明すると1日かかるので難しいんですが、結構日本人作者の方がいるので、本当にありがとうございましたって感じですね。この会場に来てる人のモジュールもたくさんあります。Tipsとして、例えばMojoliciousではそもそもDELETE/PUTというメソッドをサポートするので、擬似的にサポートさせたり、FillInFormっていって、フォームに入力した値が消えちゃった、ここまで書いたのにどうすればいいのっていう状況をなくすための処理をさせたりしています。あとはコンフィグファイルはMojoliciousのデフォルトのコンフィグローダーを使わずにやっています。セッションについては、デフォルトだとブラウザでクッキーに入れるので、それが気に入らない場合は、プラックミドルウェアセッションだとか自作セッションの管理をするといいと思います。

【6.今後へ】

　すごい駆け足ですけども、ここまでは、WAFとMVCの構成を分けることでスッキリさせることと、それに対応するMojoliciousを使った実装を、占いアプリという例で紹介しました。じゃあ実際これからどうすればいいのかというと、例えばこの資料を見てMojolicious::Liteで実装してみて、たまに「できた、俺ってばスゲー」って感じる瞬間って、僕も今でもあります。いちいちMojoliciousアプリを拡張したりとか、Tengでパターンを増やしたりとかして、そのたびに、俺ってばスゲー、俺ってばスゲー、俺ってばスゲーっていうのをやっていくと、結構モチベーションが上がっていいかなと思います。少しずつ動いて分かる、「俺ってばスゲー」体験をたくさん味わってください。

　こういうところは扱わなかったんですが、まとめとして、Mojoliciousで始めていこうと。徐々に学べるフレームワークなので、いいんじゃないかなー思っています。「分けることで分かる」ことと「分かるパターンを少しずつやろう」というキーワードを出して終わります。ありがとうございました。


yusukebe2013
YAPC：Asia Tokyo 2013におけるトーク。
MojoliciousでつくるWebアプリ入門

00：00：00
和田：はい、時間になりました。皆さんおはようございまーす。朝イチのセッション、大ホールですが、皆さん集まっていただいてありがとうございます。Mojoliciousで作る、これ発音がですね、「モジョリシャス」ってだいたい読むんですけども、「Mojoliciousで作るWebアプリ入門」ということで始めたいと思います。よろしくお願いしまーす。（拍手）
（自己紹介）
　自己紹介なんですけども、本名、和田裕介（ワダ・ユウスケ）、「ユースケ」で呼ばれてます。会社的には、所属的には小さな会社のワディットとオモロキというところに入っています。今やっている、いろいろ作ってきたんですけども、メインワークとしてやっているのは、bokete（ボケテ）っていうアプリだとか、Webサービスのバックエンドをやってます。これも実はMojoliciousで作られていて、そのへんも、ある程度の規模のアプリでも使えるよっていうあれですね。
（問いかけ）
　で、最初の問いかけです。あとこの変なおっさんみたいな人が出てきますけども、これイメージ画像なんであんまり気にしないでください。
（Perlは大規模サービスで使われているが）
　Perlはですね、大規模Webサービスで使われているみたいな印象が結構あってですね。まさにこのバックパネルのDeNAさん、livedoorさん、旧体制のところからPerlを使っていたりとか、ミクシィさんとか。そういったサイトのロゴとか見ると、あーあそこ使ってるね、大きなサービスはねっていうのが見受けられます。が、が、です。初心者の人、たぶん結構皆様の中にもいるかもしれないんですけれども、アプリに入門するっていう資料とか本とか、Webサイトである程度まとまったものとかっていうのは、まあ少ないんじゃないかなっていうのが、ちょっと見てて思いました。
（あえて去年を振り返る）
　あえて去年を振り返ると、まったく同じ条件で土曜日の朝イチでやらしてもらったんですけども、「新しいを生み出すためのWeb開発とその周辺」ということで、ちょっと若干似たようなテーマでやったんですね。ただ内容は結構違ってて、どちらかというとPerlでいろいろアプリを作るときに、じゃあ大切なのって、どうやって作るかっていうよりか、まずは何を作るか。Whatの部分が大切だなということで、企画の作り方みたいなことを、若干Perlとは関係ない文脈で話したりとかもしました。
（何をつくるかは分かった）
　で、別に続編っていう立ち位置ではないんですけども、連続性あるとして考えると、まあ何を作るかは分かったとすると、そのための実装のきっかけみたいなのが、今回の主題なのかなあと思います。
（対象オーディエンス）
　なので対象オーディエンスとしては、Webアプリを作りたい。アイデアあるんだけど、なんかきっかけがないなあっていう方だとか。Webアプリケーションフレームワークっていうのを、頭文字をとってWAF（ワフ）って読んでるんですけども、WAFについて知りたい方。あとはMojoliciousを使ったアプリについて知りたい方っていうのが対象になりますのでよろしくお願いします。
（方針）
　まず僕らが開発のときとかに当たり前に使っているのが概念とか実装とかキーワードって、実は周辺の方はわかんないとか、意味がわかんないもあるし、そもそもどういうキーワードがあるのかがわかんないというケースが結構あると思っています。なので、それを噛み砕、時間内で噛み砕いて使うことにして、あとは資料をあげるので、あ、アップロードするので、それをGoogleやCPANで検索できれば、復習できるかなと思います。っていうのが若干チュートリアル的な意味合いもありますね。という方針を立てています。
（アジェンダ）
　で、アジェンダなんですけども、まず占いアプリ。とある占いアプリを題材にして、全体的に全部を通して占いアプリを扱います。なので、その占いアプリについて解説したことに、それをどういうふうに拡張していくかというのをMojoliciousを使って考えていこうというような形になります。
（占いアプリについて）
　はい。じゃあ占いアプリってどんなもの。超簡単です。名前を何かインプットとして入力すると占い結果を出す。で、まず結果はまず3種類です。これもう決め打ち。もうテキスト。「良いことがあるでしょう」「出会いがあるかも？」「不幸になります」で、これ、大吉、末吉、凶みたいな感じのホントに3種類だけ。
　で、入力された名前に対して必ず同じ結果が返るっていうようなことをやろうと思っています。つまり「yusukebe」って、アルファベットでyusukebeって入れたら、必ず「出会いがあるかも？」っていうふうに出てきます。で、そこを、例えばPerl入学式で著名なパピックスさんだと、papixって入れると「良いことが起こるでしょう」とか。人の名前を変えるともちろん結果は変わるけども、同じ名前だと結果は変わらないっていうような仕様にします。
00：05：02
（ハッシュ関数）
　それをまず実装するときに、いきなりちょっとこう出てきたんですけども、ハッシュ関数という、ちょっと広い意味でのハッシュ関数っていうようなものを実装しなくてはいけません。実装構造はこの例でほぼ完璧です。もうちょっと短く書けるんですけども。
　何をやってるかっていうと、文字列を受け取ります。それをそれぞれ数値に直します。で、数値に対してある固定的な値で割ります。で、その余りが結果となります。つまり、yusukebeという文字列があった場合は、必ず余りの結果が0になるっていうようなロジック、つまり仕組み、ロジックですね、を実装してるんで、これを利用すると必ず同じ結果出るっていうようなことを叶えることができます。
　ハッシュっていうと、Perlのデータ構造のスカラ、配列、ハッシュっていうのとちょっと混同しがちですが、そのハッシュとは違うまったく別ものなので、ちょっとこれは注意してください。
（スクリプトで実現する）
　スクリプトで実現することもできて、.plのスクリプト言語で書くと、perl uranai.pl yusukebe。yusukebeというのが引数にしてて、そうすると結果として「出会いがあるでしょう？」が出てきます。なので、スクリプトレベルの占いアプリをWebアプリにしていくとどうなっていくかいうのを考えると。
　これ要は、もうちょっと発展させると〓ケンタ〓の診断なんとかメイカーみたいな、よくなされてきて、あなたはナントカです。ナントカさんの、@ナントカさんの結果はこんなんですみたいな。やたらバズって、そこのサイトに行くとたぶん広告が貼ってあって、これ結構簡単なのに結構儲かるなみたいな、そういう仕組みがあるんですけども、それにちょっと近いものができるかもしれない。
【1.Webアプリケーションとフレームワーク】
　はい。ちょっと本題に入ります。
（Webアプリケーションを定義する）
　Webアプリケーションを作るときに、ちょっと定義し直します。これ、具体的に言うか抽象的に言うかとか、方向性によってだいぶいろいろ人によって定義が違うと思うんですけども、ここではこうします。「Webが誰かと特徴的なインタラクションをする場合」、Webアプリケーションと呼ぼうと、いうふうに考えております。
（Webのインタラクション）
　で、例えば占いのアプリの場合だと、ユーザー、人がいてそれが、その人がブラウザを経由して人の名前、自分の名前を入れます。それに対してWebアプリケーションが占いの結果を出力するので、それを見るというこの、この矢印のやり取りですね。矢印のやり取りがWebアプリケーションにとってはリクエストとレスポンスっていうふうな形になるんですけども、この、こういうインタラクションが起こる場合にWebのアプリケーションだと言えると。
　で、例えば今の占いアプリとかもJavaScriptだけで実装できるよねとか、あるんですけども、その場合もWebアプリケーションなんじゃないのっていうのが僕の考えです。あとはWebアプリケーション自体が外部のWeb APIとかミドルウェアと連携する、そこがインタラクションだったらアプリケーションだし、例えば今度ユーザー側も単なるPCブラウザだけじゃなくて、最近だとスマホのアプリでWeb APIを叩いて結果を取得して何かをするみたいなこともよくあるんで、Web API自体もWebアプリケーションと言うことができるんじゃないかなと思います。
（Web Application Framework）
　はい。そこで、Web Application Frameworkというのがありまして、今回もYAPCでもいろいろトークされるんですけれども、通称WAF（ワフ）っていうふうに呼ばれたりもしますね。あんな形で。ただこれ、PerlのコンテンキストというかPerlの界隈では結構呼ばれてるんですけども、例えばRuby（ルビー）とかPython（パイソン）のコンテキストでWAF、WAFなんて言うと、ハニャッとかされるかもしれなくて、どれだけそういう略語が浸透してるかわかんないですね。
　ただWebアプリケーション・フレームワークの筆頭といえば世の中的にはたぶん例えばRuby on Railsですねとか。確かにRuby on Railsだと思いますし、別にdisる必要はない。僕からdisったりしないんですけども、これはまあ簡単に言うとWebアプリケーション作るための土壌、土壌とかね。
　よく言われるのが、MVCモデルに基づく場合が多いと呼ばれています。じゃあMVCってなんだ？ってことなんですけども、まあModel、View、Controllerいうふうに区分けしたもの、区分けしたものでWebアプリケーションを動かすことがMVCだよと。頭文字説いてます。
00：10：05
（MVCである意味は？）
　で、ここでちょっと、ちょっとね、深掘りしたいところが、MVCである意味ってどういうことなんだっていうことを話します。これはたぶん結構重要。
（MVC以前）
　MVC以前というのがあって、単に汚いコードを載せてるだけで、これ実はGoogleで検索すると、CGIとかで検索すると結構トップに出てきて、この場でなんか言うと大丈夫かなっていう感じなんですけども、こういうコードがあります。いわゆるCGIを呼ぶCGIなんですけども、なんかこれ気持ち悪くないですかね。
（何がイケてないって？）
　で、イケてないところがあって、いろいろ混じっているんです、1つのところに。たとえばヘッダーの出力とか、ロジック、先ほどの占いアプリの場合だとハッシュ関数を使った処理の部分ですね。その処理の部分とかも混じってたりとか、HTMLの描画とかが、結構print文とかいろいろあって、print文でやっていると。なんか気持ち悪いし、HTML肥大化するんで、print文で全部賄えんのとか。別にCGI自体っていうのは配信方法のひとつなんで、CGIを、何ですか、良くないとか、馬鹿にするっていうことはしないです、まったく。別にそれはCGIはCGIでいいんですけども、CGIの時代、CGIが流行っていた時代に、CGI的に書かれた良くないプログラムというのがあって、それを見るとなんかいけてないよねと。
（愚直に.cgiを書くと）
　じゃあそれを良くするとどうするかっていう話なんですけども、まずその占いアプリをCGI的に書くとこういうふうになります。これでも結構まとまってるほうですね。ただ、どうしてもなんか、print文でHTMLに出力するの、ちょっとダサいよねとか。もっと複雑なHTMLになったりとかしたときにどうなるのか、分岐があったらどうなるのとか。結構、柔軟ではないんですね。
（HTMLだけでも分離させると）
　で、これはフレームワーク使わない場合です。テンプレートエンジンというものを使って、今回はテキスト内蔵テンプレートを使ってるんですけども、HTMLで、HTMLを書いてその中で特殊な記号で、ここに例えば占いの結果を出すみたいな、HTMLテンプレートというものをHTML的に書くことによってだいぶ見通しが良くなるんですね。これはデータセクション以下に書いてそれを呼び出すようにしてるんです。で、結構気づくのは、あれ、コード長くなってねって感じ、ですが、見通しは良くなっています。
（冗長になるが見通しが良くなる）
　で、さらにテンプレート自体をファイル、別のファイルに分けることもできて、そうするとメンテナンス性の向上だったりとか、ヘッダー部分とかフッター部分とかっていうのを共通で使うっていうふうにやると、再利用性の向上が図れます。あと冗長性というか、冗長になった部分はフレームワークが、今後紹介するフレームワークが吸収してくれるので、あまり冗長ではないです。
（とりあえずMVCで考える意味）
　で、MVCで考える。今回はビュー、見た目の部分をちょっとクールにしてみた。そうすると混在している固まりを役割で分けますと。で、そこの感覚を理解すれば、冗長にたぶんなんないと思うんですけども、開発効率が上がるという感じですね。
（分けることは分かること）
　まあたぶん言葉としてあるかどうかわかんないだけども、分けるっていうことはよく分かることだと思っていて、そうすると役割ごとに、分けすぎもよくないんですね、分けることで分かる。だから入門もしやすいし、最初から汚いコードで書いてもいいですけども、徐々に入っていけるんじゃないかなと思います。
（切り分け方）
　あと、MVCに依らず、最近のPerlのフレームワークでよく行なわれている切り分け方なんですけども、Router、Controller、Model／Logic、DB層もしくはOR Mapper層、View、先ほどのテンプレートのところですね。こういうふうなキーワードなんかがあったりします。
（役割を分けること＝フレームワーク的思考）
　で、こういうふうに役割を分けることが、フレームワーク的思考ではないかなと思っています。
（処理の流れ）
　で、今のコンポーネントを処理の流れとして見せると、最初にリクエスト、アクセスがきたらRouterと呼ばれるところがURLのpathと、あとHTTPのGETかPOSTかっていうメソッドによってディスパッチをしてコントローラというところに行って、コントローラが処理ロジックを呼び出して、DBが引っかかったら通信をして、結果をコントローラに返すと。で、先ほどのようにテンプレートなどを使って、HTMLとかもしくはJSONとか、XMLの場合もありますけれども、何かの形でレスポンスを返すっていうふうな流れになってます。
00：15：05
（PerlのWAF達）
　こういうものを実現するためのPerlのWAF達。ちょっと出せるだけ出してみたんですけども。最近だと、Amon2（アモンツー）、結構今回トークでも結構多いですね。Amon2、tokuhiromのAmon2もいいと思います。別に僕はニュートラルな状態で言いますけども、あとは今回紹介するMojolicious。
　でCatalyst（カタリスト）っていうのは結構日本のコンテキストだと、異例な感じで扱われていて、5年位前はみんな使って、わーわーわー使えるぞ、すげーっていう感じだったんですけども、突然、ある日突然から、いやこれちょっと重厚すぎないかっていうふうな感じでちょっと切られて、最近ではあんまり使ってる人はいないですね、日本の中で。ただUSの文脈、アメリカの文脈とかほかの海外の文脈だと、まあ、未だにCatalystは使われているので、そこを別に変な偏見を持たないでCatalystっていうのも〓向いて〓みるといいかもしれないです。
（自作WAFと既存WAF）
　最後に自作WAFって書いてありますけども、MVCみたいな、先ほどのコンポーネントを組み合わすものを実現するモジュールって非常に揃っていて、まあ、Plack（プラック）っていうユーティリティツールのPlack::Request（クラップリクエスト）とか、ルーティングをするRouter::Simple（ルーターシンプル）とか、ビューを吐き出すText::Xslate（テキストエクスレイト）とか、この辺を使うと結構WAFって自分で作れちゃうのね。すっごい楽しいんです、これ。ただ、上の上位のアプリを作って、しかもその土台のWAFを作るっていうようになると、結構きついんですね。考え方を変えなくちゃいけないので。なので、まあ勉強用にとか、ちょっと余暇。余暇って休日がありまして、なんか作ろうかなっていうときに、車輪の再発明になりますが、それは大いに歓迎すべきことかなと思います。ただ、とりあえずWAFを使いましょう。
【2.Mojoliciousの紹介】
　で、もちろんMojoliciousの紹介です。モジョリシャース、イエーイ！みたいになって。
　俗に言う軽量WAFの一種。これも軽量って先につけてるのは、Catalystっていうフレームワークが、まあ別に中身知らなくてもいいんですけども、重厚だと呼ばれてるから軽量というふうにアンチテーゼに言われているフシはあります。で、最新バージョンが、4.35じゃなくて、たぶん4.36とかになっているはずです。なので、リリースはすごい早い。で、作者がセバスチャン・リーデル氏で、実はこの人はCatalyst作った人です。
　で、あとすごい個人的に気になるのが、このアイコンが、なんか、すごい気取ってて、ちょっと最初抵抗感あったんですけど。でもドキュメントを何回も見てて見慣れます。
（特徴 1．CVだけサポート）
　特徴なんですけども、MVCで考えるとVとCだけサポートしてます。まあ、ルーティング、コントローラ、まあその部分担当してて、あとはmojoテンプレートっていうのに準ずるテンプレートの書き方をするとテンプレートが書けます。で、それだけサポートしてて、モデルは勝手にやってねっていう方針です。これは結構逆にそれが良くて、モデルとかロジック、占いで言うとハッシュ関数を使って占いの処理するところっていうのは、Webから切り離して考えることができるんで、そうするとほかのコマンドラインインターフェイスから使ったりというのもできる。だから切り離すべきだなあと僕は思っています。
（特徴 2．Not full-stack but full-stack）
　その2なんですけども、ノット・フルスタック、バット・フルスタック。なんで否定して肯定してるのみたいな感じで、何言ってるのコイツって言われるかもしれないんですけども、例えばRuby on Railsだと、データベースを扱う、それこそモデルを含めてすべてこれ1つでできるよねっていうふうな謳い文句で、これだけ使ってればWebアプリケーション全部できちゃうからっていう意味で、機能的な意味でフルスタックっていうふうに呼ばれています。で、Mojoliciousはモデルをサポートしないから、フルスタックとは、そういう意味では言えないんです。ですが、実装の部分を見ると、HTTPのリクエストオブジェクトとか、ユーザエージェント、LWP::UserAgentみたいなユーザエージェントまでMojolicious内で使うライブラリがすべて自作されています。なので、そういう意味では実装面ではフルスタックと言えるんです。
　何言ってるかわかんないっていう雰囲気がこれだけ多いと思いますけども、つまりPerlのコアモジュール以外の外のライブラリに依存してないんです。なので、こんだけ、もっとたくさんあるんですけども。モジョのPage見ると、いろんなものを自作してるんですね。使うもの。その代わりほかのものも使ってない。
00：19：50
（$ cpanm Mojolicious）
　だから、簡単に言うと、CPANM Mojoliciousエンターってやると、外部のモジュールを取ってこないでこのモジュールだけ入ります。Mojoliciousだけ入ります。で、かつ、モジュールとかも考えないで、ちょっとしたアプリケーションでしたら、今回紹介するようなアプリケーションでしたら、Mojoliciousを入れるだけで動くという意味ではすごくポータビリティが、どっかで動かすっていうことがすごく楽なフレームワークです。
　ということで、Mojoliciousなら一発だよっていう、まあね。
（特徴 3．その他）
　で、その他の特徴なんですけども、アップデートが頻繁なんで、例えばrender\_jsonっていうJSONを吐くメソッドがあったんですけど、これが実は廃止されまして4.0、0以上で。とかあって、ただ依存がまったくないので、Mojoliciousだけ追ってれば、結構対応できる。あと、Mojolicious::Liteっていうのをこれから説明するんですけども、ファイル1個だけでWebアプリケーションができるっていうのが特徴のライトモードっていうのがあります。で、工夫すればCGIでも動作可能で、実際僕も仕事でそれをやったことがあります。あと開発用のサーバーとしてmorbo、本番用としてhypnotoadというのがあってですね。まあでも、実はPSGIに互換しているんで、PlackっていうPSGIに対応するアプリケーションツールのモジュールを使うと、plackupとか、あとはStarmanというサーバーとか、Starletのサーバーとかで動かすことも可能です。で、実際僕もplackupで開発をして、本番環境ではStarmanで動かしてます。
（小さなアプリから大きなアプリまで）
　なので小さなアプリから、Mojolicious Liteみたいに小さなアプリから、スケールするような大きなアプリまで対応してて、ひと言で言うと徐々に学べるフレームワークかなあと思います。というのもMojolicious Liteを使って、今度はMojoliciousのMojoliciousっていってるのを使って、CPANモジュールを組み合わせていくみたいな感じで、だんだんとステップアップしていくことができるんじゃないかなと。
【3.Mojolicious Liteを使ってみよう】
　てことでMojolicious Liteを使ってみましょう。
（mojoコマンドによるスケルトン）
　mojoコマンドっていうのが、Mojoliciousインストールすると入るんで、それによってスケルトンっていう雛形を作ることできます。
　で、それをちょこちょこっていじると、ハローワールドみたいなのができますね。まあ単にハローモジョを表示させるだけなんですけども、これを見ると、結構ポイントがあって、「get '/'」（ゲット・スラ）っていう先頭に書いてあるやつ、あるんですけども。これがスラッシュですね。要は、yusukebe.comのスラッシュみたいなところにアクセスして、した場合どうするかってのを定義してます。これがルーティングっていう意味合いにあたります。で、サブルーチンのこの「sub」の中の部分があるんですけど、ここが、Controllerに値してて、$selfを取ってきて、その$selfにいろいろやるんですけども、stashっていうところのmessageっていうところに、'Hello Mojo!っていう、何かテキストを入れます。これをテンプレートに渡したいっていうのをこうやって書きます。レンダリングするときに、〓1枚のカミ〓がデータセクション以下に書いたテンプレートがレンダリングされるんですけども、messageっていう変数名で渡してるんで、$messageで、ここで展開される。で、実際の描画はここにHello Mojo!っていうふうに入るっていうのが、いっちばん簡単なMojolicious Liteのアプリです。
（立ち上げ方）
　立ち上げ方は、morboを使ってもいいし、plackupでも立ち上がる。
（Hello Worldから学ぶ）
　で、学べることは結構あって、さっき説明した通りで、あとPOSTメソッド、「/entry」にPOSTを投げたときはこういうふうに書けるし、例えば「/entry/123456」みたいな、例えばブログみたいな仕組みがあって、エントリーナンバーで管理するときに、その1234っていうところをキャプチャすることもできます。あとは、テンプレートにメッセージを渡す、データを渡すときには、stashを使います。で、変数で展開させると、テンプレートの中で展開されて、Hello Mojo!っていうのが出たりとかって感じですね。
（もちろん占いアプリも）
　もちろん占いアプリも作れますってことで、時間が結構ないけど、ショートライブコーディングってのをやってみます。
　これが占いの、先ほど言った通りのコマンドラインに出すやつですね。なので、こうやると、yusukebeってのが引数になってプログラムに渡るので、「出会いがあるかも」って出ます。これが占いです。はい。だから、先ほど言った通りハッシュ関数を通しているので、いくらyusukebeって入れても、この結果になって、で、例えばpapixとかってやると、良いことが起こるでしょう」と。ああ、良かったですね。で最後にdankogaiって入れます。入れると「不幸になります」。（笑）
00：25：05
　これは本当にそういう●に従ってそうなったんです。で、コードはこの通りで、リストの中に入れてます。えっとここがハッシュ。この部分がハッシュ関数の部分ですね。で、じゃあ作る。はあ時間がない。
　generate liteup uranai mojo.pl。これで作られるんですよ。で、編集します。uranai mojo。これがデフォルトで、立ち上げましょうと。立ち上げるときにplackupします。で、引数でこうやって指定することでファイルが書き換わっても自動的に再起動するんで、5001番コードで立ち上げます。あれ、なんかおかしいな。えーと。あ、そうだ。ファイルを指定しなかった。ファイルを指定すると自動的にpsgiが入ってくれます。よし、ローカルホスト、エイってやると、出てきましたね。
　これがデフォルトの状態ですね。で、デフォルトとかなんかヤなんで、変えると。全部消しちゃおう。で、じゃ単にテンプレートでハローヤプシーとかいって、ヤフーじゃない、ヤプシーとかってやると、どうなってるかというと、変わってる。うん。
　これ、まあ、ある程度立派なWebアプリです、これでも。
　で、例えばメッセージを、stash、メッセージ、えーと、なんだろうね。ヤプシー、カモンってやるじゃないですか。メッセージってのが変数に入るんで、ここで展開したければ、メッセージって打つと、出てくる。
　これがstashって言って、コントローラから変数を渡します。
　で、じゃいよいよ占いアプリなんですけども、なんか、ちょっと怪しいタイトルつけますね。で、フォームで入力してもらうんで、フォームタグを使うんですけども、そのときにフォームのアクションの先がresultっていうふうに例えば仮定します。テキスト、ネーム、イコール、ネームっていうパラメータで飛ばしてもらいます。で、つまり、ここまで書いたらサブミットボタンを作んなくちゃいけなくて。だんだん。
　そうすると、こうゆうふうになって、ま、一番やりたいのは、yusukebeってやると結果が出ることなんですけど、、もう、/resultに飛んでる、URL的に、それが実装されてないっていうふうに怒られます。なので実装します。で、パラメータ、ネームでパラメータを取るので、ここでネームってやっちゃえば、そのままネームってふうに渡すこともできます。
　で、えーと、レンダリングするパスが、もう1個テンプレート作んなくちゃいけなくて、resultっていうテンプレートで、こうなりますよね。で、名前、表示したいじゃないですかっていうので名前を展開します。エラー出てないね。大丈夫かな。出た。ちゃんとここに、フォームに入力したのが出ました。
　じゃあ、この名前で占ってみたいです。占ってみるのに、いちいちロジック書くのメンドくさいんで、こっからコピペします。よいしょ。うん、コピペして、しかも名前、変数名も同じなんて、このまま動きます。
　で、このメッセージっていうのに占いの結果が入るので、メッセージっていうのに渡します。さらに、ここで、占いの結果は、メッセージだよねーっていうふうにやっていくと、出る、かな？ 出たらちょっと拍手してください。出た。（拍手）
00：30：07
　2度入れてももちろん同じ結果になります。で、さっきと同じ通り、おんなじロジックなので、おんなじロジックってことは、こうなります。すいません。（笑）。
　てことでちょっと。以上です。ライブコーディングは。で、この辺は良くてですね。
　何となくお分かりになったと思うんですけども、コントローラ内での操作はですね、ダラーセルフ（$self）でもらったやつで、全部こうなってます。なので、キー（key）っていうパラメータの値を取りたかったら、セルフ・リック・パラム・キーで取れます。であとは、テンプレートをレンダリングしたかったらレンダーリストを使ったりとか、あと説明しませんでしたけども、redirectとか302 redirectとかも、redirect\_toっていうメソッドがあったりします。
　これ、Mojoliciousコントローラっていうライブラリを、モジュールを継承したものというか、そのものなんで、そのドキュメントを読めば結構分かります。
（Mojo::Template周り）
　で、テンプレートが今のmojoテンプレートってのに準ずるテンプレートの書き方で書いたんですね。で、これはパーリッシュテンプレーツって書いてあって、Perl書けるんですよ、メッチャ。なので、配列リファレンスを渡して、コードでエントリーを回して、エントリーズっていう変数を回して、そこのタイトル表示するってのは結構やったりもします。
　で、これってPerlなんで、デザイナーさんに渡すのが結構難しかったりとかするかもしれないんですけれども、まず1人とかでやる分には結構これで良かったりします
　で、この辺のmojoテンプレートとか、Mojoliciousプラグインデフォルトヘルパーとか見ると、ドキュメントを見ると、やり方が結構わかる。
（Mojolicious::Liteアプリを拡張する）
　もうちょっと拡張したいときに、例えば画像を出したいんだけどどうすればいいのって言ったら、public/っていうディレクトリを作るとその中に画像を置いて、/css, /stylesheetとかっていうふうに指定すると自動的に読み込んでくれます。あとテンプレートファイルをデータセクション以下に書いていましたけど、それファイルに分割してtemplates/っていうディレクトリに入れると分けることもできますので、この辺は結構便利ですね。
【4.より実践的なアプリへ）】
　で、より実践的なアプリということで、まあひと回りは、とはいえ大きくなる場合があります。そこでLiteじゃないMojoliciousでアプリを作ると、モジュールをいい感じに作って分けることができます。
　で、分けることは分かるんで、そういう、より分かりやすいことになると。
　結構推奨としては mojo generate app MyAppみたいな感じのコマンドを叩いてねって感じなんですけども、MyAppっていうようなネームスペースじゃなくて、MyApp::Webっていうようなネームスペースで作ってます。つまり、占いのWebの場合だと、Uranaiっていうので作るんじゃなくて、Uranai::Webっていうふうに指定します。
　これなんでかというと、Uranaiっていうネームスペースで作ると、Uranaiっていうモジュール自体がWebをサポートしなくちゃいけないってことになります。ただ、Uranai::のModelとかLogicとかっていうようなモデル層をこういうネームスペースで作りたかったり、あと、コマンドラインインターフェイスそのもののモジュールをUranai::CLIみたいな感じのネームスペースで作りたかったりするときにちょっと困るし、Uranaiっていうアプリケーション自体が単にWebだけじゃない。Webの層だけじゃないっていう意味では、こういうふうな作り方をします。
　結果的にだいたいlibディレクトリの下って、ざっくり言うとこんな感じなんで、一番上からDBレイヤー、使う場合はDBレイヤー、例えばTengっていうORマッパーのモジュールを使う場合は、こういうふうになったりとか。あるいはビジネスロジックを使う、扱うようなところですね。で、WebのところはWebレイヤーとコントローラと、あとルーターってところですね。
　じゃあLiteから移行するときどうすればいいのって話なんですけども、結構概念的にはほぼやってることは同じなんで、すごくファイルを分けるだけで移行することができると思います。web/subっていう、ルーティンのところは、lib/Uranai/Web.pmでルーターの定義をすることができるので、そこに移行させると。コントローラの部分は、lib/Uranai/Web/Controllerとか、RootとかEntryとか、こういうファイルで作って、コントローラを書いていきます。これはMojoliciousコントローラのどちらでも継承した形になっているので、Liteでも普通のMojoliciousアプリでも、似たように、ほぼ、ほぼ、ほぼおんなじで書ける。テンプレートの部分もファイルに、別ファイルに分けるだけでmojoテンプレートっていう文法に沿ったテンプレートの書き方でよいと。すんなり移行できるということですね。
00：35：10
（占いアプリを実装してみる）
　占いアプリを実装してみると、実装方針として、ちょっともうちょっとカッコ良くしようというところで、占いのロジック、ハッシュ関数があるところをモデルとして切り出すといいんじゃないかなーという感じですね。で、MouseっていうClassビルダーを使って書くと、ベタ書きですけどこうなるんです。
　で、こうすると何がいいかっていうと、CLI、コマンドラインインターフェイスから、このコード実際動くんで、単体で動かすことができます。なので、面白いロジックがあって、それをWebでも活用できるし、コマンドラインでも活用できるっていう、そういう良さがあるし、何よりも、テストの話ってあんまりしないんですけども今回、単体でモデルだけでテストをできるってのがすごくポイントだったりします。
　で、ここはコントローラなんかだと愚直に呼んでますけども、useして、これもモデルをどういうふうにロードするかっていうのは議論の余地あるかなーと思います。
　で、こういうふうにやっていくと、とりあえずモデルを書いて、それを単体でテストして、ルーターのところとコントローラを書いて、テンプレートを書いて、テンプレートのところがHTMLとかジェイソンとか入ってくるんで、けっこう大変かもしんないんですけども、やっていくと。さっきみたいにテストサーバー記録して、自動的にファイルの先が変わる度に再起動するようにさせておくと便利だったりするんですけども、ブラウザで確認して。この繰り返しですね。赤字のところが確認するところ。
【5.CPANモジュールとの組み合わせと工夫】
　時間ないんですけども、CPANモジュールを使わないと、ただMojoliciousでは足りない部分があって、Mojoliciousをベースとして、いろいろORマッパーとかフォームバリエイターとかを使っていく。まあレゴのブロックみたいだよね。
　ちょっとだけ紹介しますけども、例えばFormValidator::Liteみたいなものは、そのままわりとカジュアルに使えるかなと。で、フォームバリエイターってどういうことっていう感じなんですけども、入力値の妥当性をチェックするためのモジュール集。モジュールネーム空間ですね。例えばどういうことかというと、メールアドレスがメールアドレスっぽいかっていうのを判定したりします。@がついてどんな感じでとか。郵便番号は7桁の半角数字だよーとか。文字数、例えば普通ツィッターのつぶやきは140文字以内だよねーとか。そういうのをチェックするのにいちいちルール書いてるとちょっと大変なんです。なので、それを簡略化して、名前は、ネーム、ネームのパラメータは必ず必須で、メールってパラメータはEメール形式でみたいなことをルール付けして、適切にエラーが出ているかどうか、で、エラーメッセージをその場合に出すとかっていうことをやってくれると。
　で、Tengってのを使うとORマッパーで結構簡単にデータベースを触ることができます。で、例えば3つの選択肢があったのをどんどん増やすことができたりとかができる。で、それをやるのにデータベース作って、Tengのスキーマを作って、モデル化するようにして、簡単なテストを書いて、コントローラーを呼び出して、ビューの変更して、できたー！ みたいな感じで、どんどん拡張して作ることができます。
　で、その他、僕が実践で使ってるモジュール。これ全部説明したいんですけども、そしたら1日かかって難しいですが、結構日本人作者の方がいたりとかして、ホントにありがとうございましたって感じですね。ここに来てる人、会場の、会場に来てる人のモジュールもたくさんあります。
　で、Tipsとして、例えばMojoliciousではDELETE/PUTというメソッドをそもそもサポートするので、擬似的にサポートさせたりとか。FillInFormっていって、フォームに入力した値が、消えちゃった、どうすんのこれ、ここまで書いたのにっていうのをなくすための処理をさせたりとか。あとはコンフィグファイルはMojoliciousのデフォルトのコンフィグローダーを使わなかったりとか。やってます。あとセッションなんですけども、デフォルトだとクッキーにブラウザで入れるんで、それが気に入らない場合は、プラックミドルウェアセッションだとか自作セッションの管理をするといいと思います。
【6.今後へ】
　はい。紹介したことは、すっごい駆け足ですけども、WAFとMVCの構成。で、分けることでスッキリとさせると。対応、それに対応するMojoliciousを使った実装を、占いアプリという例で紹介しました。
　で、じゃあ、じゃあこれから実際どうすればいいのって感じなんですけども、例えばこの資料を見てもらって、Mojolicious::Liteで実装してみて、たまにこういう瞬間って僕でも今でもあって、できた、俺ってばスゲーっていうふうに感じることがあって、いちいちですね、Mojoliciousアプリを拡張したりとか、Tengでパターンを増やしたりとかして、そのたびに、俺ってばスゲー、俺ってばスゲー、俺ってばスゲーっていうのをやっていくと、結構モチベーションが上がっていいかなと。
　少しずつ動いて分かる、俺ってばスゲー体験。
（扱わなかった主な点）
　で、こういうふうなところは扱わなかったんですが、まとめとして、Mojoliciousで始めていこうと。徐々に学べるフレームワークなので、いいんじゃないかなーということで、キーワードは、「分けることで分かる」ていうのと分かるパターンを「少しずつやろう」ということで終わりです。ありがとうございました。
00：40：11

