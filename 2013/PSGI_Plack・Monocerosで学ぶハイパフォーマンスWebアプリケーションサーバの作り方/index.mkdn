nagano2013
YAPC：Asia Tokyo 2013におけるトーク。
PSGI/Plack・Monocerosで学ぶ
ハイパフォーマンスWebアプリケーションサーバーの作り方

00：00：00
長野：はいじゃあ始めまーす。「PSGI/Plack・Monocerosで学ぶハイパフォーマンスWebアプリケーションサーバーの作り方」ということで喋ります。
　軽く自己紹介なんですけど、長野雅広といいます。IDとか〓カゼブロ〓というんで、社内でカゼブロさんと呼ばれています。オペレーション・エンジニアです。〓運用〓エンジニアをやっていて、ラインで働いてます。先ほどの〓セイイチ〓さんといっしょで、グループにいて、ラインの、ラインなんとかっていうサービス会社、ライブドアの関連のところの開発のサポートですね、開発支援をしています。
　ライブドアなんですけれども、ライブドアブログが今年12月で10周年だそうです。10年だそうです。10年前何やってたか覚えてないですけど、10年経ってます。このライブドアブログなんですけど、今なんですけど、動かない。
（PC不良 − 00：02：16）
　続き行きます。ライブドアブログなんですけど、今Perlの5.16で動いてます。あとごくごく一部でまだ5.1が動いてますね。で、〓デコライ〓などのCartonをもう使い始めてます。Cartonの1.00を使っております。あとPSGI、Plackももちろん使っていて、過去には〓Perlのほう〓も使ってましたけど、メインのところはだいたいこのコードが担当しています。スタックの〓トウロクナンダン〓もリクエストでそのヘッダーですね、見ていただくと「Plack: :Handler: :Starlet」と出てきているはずです。
　このStarlet、今だいたい1日で10億リクエストぐらいさばいてます。何台かっていうのはちょっと言えないでんすけど。10億リクエストですね。HTMLだけじゃなくてJSONだとかそういった、JS、動的な〓ゲーアイ●〓を含んだ値です。
　この10億／デイリーのアクセスをさばくために、いろんなレイヤーでのパフォーマンスのチューニングっていうものを毎日やっていかないと、さばくことができないし、1ページ当たりのコストというのをどうしても下げないといけないんで、そういった挑戦をしていると。どんなレイヤーがあるかというと、軽く書き出すとこんな感じで、上から下まであるんですけど、今日の話す内容っていうのはこのアプリケーションサーバーのレイヤーですね、これが今日のお題です。
　ところでなんですけれども、オープン・シェアとオーバーズ・シェアっていうのを、ライブドアの時代からずっと言ってることなんですけど、たくさんのCPANとオープンソースをソフトウェアを使ってるし、〓トーキング〓もしています。
　ライブドアブログのこのパフォーマンスを上げているっていうことが、そのままたぶんPlackだとかPSGI、StarletだとかCPAN上のモジュールのパフォーマンスを上げていくっていう、そういうことだと思っています。
　われわれが、左側なんですけど、まだネットワークを使っていた時代から、半年くらい前ですけどそういう形で今一番新しいモジュールのバージョンでパフォーマンスを比べると、これだけの差が出てきてます。倍ですね。いろんな工夫をしていっている中でこういうふうなことが起きてました。
（Monoceros）
　その次の話題なんですけど、Monoceros（モノセロス）のサーバーを、どのくらい前からな、3、4ヶ月前からずっと作っていってます。これは何かというと、PSGIのサーバーで、実験的な機能もあるんですけど、パフォーマンスを出すために作られたWebサーバー、PSGIサーバーです。
00：05：00
　どんなことを目標としてるかって言うと、TCPのスリーウェイ・ハンドシェイクですね、TCPの接続のためのコストを下げようっていう。どこのTCPの接続かっていうとリバースプロキシーとPSGIのサーバーとの間がメインの狙いです。
　通常、リバースプロキシーとサーバーはどうやって通信してるかっていうと、まずTCPの接続を作るために専用ルーターを書いて、〓遅延アプリを取り除いて〓、TCPの〓セキレイの支援〓を行なってようやく接続を完了して、〓デート〓リクエストを送ってレスポンスをもらう。レスポンスが終わったらだいたいこのようなところで接続が切れて、次のリクエストのときには〓支援〓が増えている。一度接続をして直さないといけない。これっていうのは、パフォーマンスを出さなくちゃいけない、リクエストが大量に来ている中ではこれがボトルネックになるということがあります。
（Keep Alive）
　だからもういろんな工夫をしなければ。HTPP1.0-1.1ってのにはそもそもKeep Alive（キープアライブ）っていう機能があります。これは何かっていうと、一度接続したときで、1.0だったらコネクション〓キープアライブ〓っていうのをいったん送って、アプサーバーからコネクションキープアライブが本当は返ってきて、それに1.0の場合はコンテンツの中、そうですね、というのが返って、どこでそのコンテンツが終了するのか、このコンテンツの終了までが読み終わったら、次のリクエストを送っていいというふうな状態にしたうえで、接続がうまく、どこかで、どこのコンテンツが送っても確認していこうと。HTTP 1.1の場合はトランスファー変更時に〓チャントトランスファー〓っていうのがサポートされていて、デフォルトでキープアライブを送ります。
（C10K problem）
　ただ、これ使えばいいかっていう話なんですけど、ただここにも問題があって、いわゆるC10K（シーテンケー）問題ですね。コネクションを大量に張ったときにどう動くかという問題です。
　昨日発表中にいたんですけど、Apacheを使っているという、Apacheを使っているのはもう古い人とか言ってるんですけど、〓エンジンXのわり方〓もデフォルトでもうC10K、コネクションいっぱい張っても大丈夫なような設定になってると。そのコネクションいっぱい張ってる状態から、アプサーバーに向かってキープアライブのリクエストを大量に張ると、アプサーバーは当然詰まります。
　なぜかというと、プリフォーキングモデルで1コネクションにつき1プロセスが占有されるという問題があるという話をされたんです。
　Starmanの場合はデフォルトで5プロセス、Starletだと10プロセス上がるんですけど、これ一致しないとこれで5つのコネクションでいっぱいになるし、Starletも5つのコネクションでいっぱいになると。例えば100個とか200個くらいまでだったら直接上げることはできますけど、1,000個2,000個というプロセスを上げると、それはもう通りにくくなる。〓ファウル〓の原因になってしまうというのがあります。
　Monocerosっていうのは、プリフォーキングのモデルなんですけど、コネクションをいっぱい張れるという面白い特徴を持っています。
　どういった仕組みなのかっていうと、まずクライアントが普通にワーカープロセスに、〓レコグド〓されたワーカープロセスに向かってリクエストを送った、処理してレスポンスを返したあとに、これをマネージャーのプロセスに返します。後ろで〓unixドメイン〓の通信をずっとマネージャーを通して〓ストラッカ〓プロセスがしていて、マネージャーを通してそこで監視します。ここで〓ケントトウループ〓で監視していて、クライアントから次のリクエスト、キープアライブの次のリクエストが来たらこのソケットを〓こいつの〓空いてるバッファに渡す。そこでリクエストを処理してレスポンスを返す、こういう仕組みになっているんで、コネクションによってプロセスが占有されることがないっていう構造になっています。
　このワーカーなんですけど、このままユースケーススタディとしてあって、これ〓そのまま張る〓一般には使えないんですね。ただ、イベントドリブンでできているこのマネージャープロセスっていうのが、エニ−イベントでできているので、〓それ作れば〓それ以降、そういった仕組みになっています。
　ベンチマークなんですけど、通常のAPの例えばバッチベンチなとこっていうのは、接続を張ればコネクションを使って大量のリクエストを送るっていうふうなベンチマークになっていて、通常のたくさんのブラウザがある状態から大量のリクエストが来るっていう状況を再現できないんですね。
00：09：55
　それを再現するときにちょっと別のプログラムを作って、接続をして何かのリクエストを送って、そのリクエストがキープアライブがタイムアウトで切れるまで放置するっていうベンチマークをすると、左側がStarletでMonocerosが右側で、トータルタイムが54秒と8なんで〓6秒と5倍〓くらい速いんで、しかもリクエストの失敗もない。タイムアウトしてしまいません。大量のリクエストを送ってるけどプロセスがその〓スリット〓を受け取ってくれないからタイムアウトして失敗すると。そういうことがMonocerosではないっていう特徴を持ちました。
　Monocerosなんですけど、結構頻繁にバージョンを〓僕が〓上げているんですけど、だいたい安定しているんじゃないかなあとは思ってます。なので、プロダクションでぜひ使ってみてください。
（Plack/PSGI Basic）
　今まで散々PlackだとかPSGIっていうのを言ってたんですけど、そもそもそれって何だっけってのをこれから話します。
　結構、口酸っぱく言われてると思うんですけど、PSGIというのは仕様です。PlackっていうのはそのPSGIの仕様をインプリメント、実装したものです。PSGIって何かっていうと、アプリケーションをサブルーチンで表現して、env（エンブ）というふうなものを受け取ってレスポンスを返すと、こういったものになってます。
　envなんですけど、何が入っているかっていうと、CGIの時代からやってた方っていうのはよくご存知のこの、ちいちゃい、いわゆるkey。ハッシュのkeyですね。リクエストだとかHTTPなんとかっていうヘッダーの情報が入ってきてます。それに加えて、PSGIが使う〓バイセン〓だとか、インプットとか、エラーの、〓スタットっていうのはスタットのときのいうのがよくあるいれると〓、それが入ってます。
　レスポンスというのがどういう形があるのかっていうと、まず一番オーソドックスな形なのがこれで。大きく分けて3つですね。一番最初がステータスコード、HTTPの、200〓オッケーの200〓ですね。2番目というのがヘッダー、これが配列のリファレンスですね。これは大事な。最後、配列の中に文字、コンテンツを入れるという形になってます。
　あとはちょっと別な形として、こういって、IOハンドラですね。IO〓へフリ〓、IOタイプだとかっていうものを、オブジェクトを渡すこともできます。
　こっからは結構難しくなってくるので簡単に流すんですけど、レスポンスをいきなり返すんじゃなくてサブルーチンだけを返しておいて、その中で遅延させてレスポンスを返してやるとか、先にヘッダー文字だけ送ってレスポンスをさらに各処理に返していくっていうこともできるようになっています。PSGIの仕様の中ではサポートされてます。
　PSGIのサーバー、何をするものなのかっていうことなんですけど。簡単に言えばenvを作って、アプリケーションを実行して、返ってきたレスポンスをもらって、それをプロトコルに合わせた形で出力するというものですね。
　簡単に凝縮するとこんな感じですね。
　Apacheだったら〓CJケーリング〓だったり〓ボットパー〓だったり、〓エンジンX〓で〓CJ、パースCJ〓を使ってアクセスしてきて。いろんなプロトコルでアクセスしてくるんですけど、最終的にはenvを作ってアプリケーションを実行して、ソフトをもらって、そのレスポンスの配列をプロトコルに合わせた形で整形して返してあげる。これがPSGIのサーバーの役割です。
　PSGIサーバーなんですけど、また別の名前で、Plackハンドラっていうことで呼ばれたりもします。Plackサーバー、Plackハンドラって呼ばれたりもします。
　何か違うかっていうと、PlackハンドラっていうのはPSGIサーバーとPlackとのインターフェイスです。簡単に言うと、PSGIサーバーをplackupで実行するための〓ADI〓です。
　スターマンStarman::Server（スターマン・サーバー）っていうモジュールが実際PSGIサーバーの実装。Plack::Handler::Starman（プラック・ハンドラ・スターマン）っていうのが、Plackハンドラ。こういうふうな関係になってます。なのでStarletでMonocerosのソースコードを〓切る〓ときもだいたいこの形式になっていて、Starletサーバーがあって、Monocerosサーバーがあって、Plackハンドラがその2つとの間。こういう関係になってます。
（Make PSGI/Plack Server）
　ここから、PSGIの仕様がだいたいわかったところで、PSGIのサーバーを実際ちょっと作ってみようという話になります。スタンドアロンで動く簡単なWebサーバーを作るとだいたいこんな感じです。細かく読まなくてもいいんですけど、60行ぐらいでだいたい動くハンドラができます。
00：14：57
（Listen and Accept）
　ちょっとずつ見ていくと、リッスン（Listen）指定。そのソケットを受け取るところですね。IOソケットを使って5000番をリッスンして、何か新しいことが出たらヘッドをコネクト。この前のアクセプト（accept）っていうところで、ソケットの新しいソケットが来るのを新しい通信が来るまでブロックしてくれるので、こうやってホワイル（while）で回しておくと動くってことです。
（Read a request）
　次の、リクエストを読むところっていうのがこんな感じです。ごにょごにょとenvを作るところだけ要するんですよ。envを作って、最後のところ、一番最後の行ですね。〓パーセイHTTPリクエスト〓、これが、〓Plack HTTPパーソン〓っていうところから提供されるものなんですけど、HTTPのヘッダーを〓ファンスファンス〓して、envのところに適当に打ち込んでくれる、そういうモジュールになってます。これがあるだけで、すごい、うちでWebサーバー書くことがすごい簡単になってます。
（Run App）
　その次、envができたんでアプリケーションを実行するところなんですけど、上のが一番簡単にプリミティブに書いた棒打ちをする感じですね。下にはPlack〓カル〓辺りから提供されてる機能ですが、下の場合だとapp（アップ）を実行するところの〓トウロ〓に〓イワロ〓をかけて、さらにその中にはエラーになる、エラーのレスポンスを作ってくれるところで入れてます。なので下を使ったほうがシンプルになります。
（Write a response）
　最後、レスポンスを返すところですね。これも結構長いんですけど、やってることっていうのはヘッダーの配列をくるくる回して、レスポンスヘッダーを作っていって、最後に〓ジスライト〓でそれを書き出す。ホイールのところの配列なんですけど、ぐるぐるジスライトで回して最後に通す。
　これで一応できて、サーバーのこと、さっきのコードなんかも実行することができるんですけど、たぶん遅いです。問題っていうのはいくつか。
（This PSGI Server has some problem）
　問題あるのは、大きく分けると3つで、一番に受けれるっていうか、さっきのプロセス1つなんて、1つしか通信リクエストは受けることができない。あとタイムアウトがないんで、タイムアウト、Telnetでアクセスして放置しておくとほかのリクエストを一切受け取ることができないですね。あと、あんまり速くないっていうことがあります。
　なのでこれをチューニングしていきましょうっていう話です。
（Increase concurrency）
　まず、コンクレンシーですね。大量のアクセス、いくつかのアクセスを書いて出れるようにしようと。
（Multi Process IO Multiplexing or Both）
　方法はいくつかあるんですけど、マルチプロセスにする。プロセスをいくつか立ち上げて、それらがリクエストを受ける形にする。または1つのプロセスなんですけど、IO多重化によって1つのプロセスの中でいくつも通信を受けることができるようにする。もしくは両方やる方法があります。
（Preforking model）
　ここで採用するのはプリフォーキングで、IO多重化は結構面倒くさいし使い道も限られるので、こっちのほうがいい。シンプルにできる。スケーリングします。
　プロセス、プリフォークの。さっきのMonocerosのやつもすごい似ているんですけど、簡単に説明すると、まず〓デレクター〓でマネージャーの親プロセスでバインドしてリストにするところまでいきます。そのあと子プロセスを〓コウキ〓していってその中で〓セイトウ〓のところで止まっていくと。これがある。こういった動きをするのがプリフォーキングのモデルです。で、クライアントはそれぞれのところに通信をしていくっていうもの。
　このプリフォーキングを使うにはどうしたらいいかというと、〓バリヤク〓をどう動かそうとするのかが重要なんです。これを使うのが一番簡単です。これ〓プリフォーク〓で、この場合〓マックスオータ〓のところで5つバックアッププロセスを起動して、〓キュー〓とかされたときに〓とまりえる〓感じでシグナルレシーブなんですけど、〓コステ〓の中で、その動きの中でスタートというところで、このスタートのところで子プロセスを起動していくと。その中では役割の配分が入ってくる。まあこれだけで、その子プロセス起動するのに5つまでコネクションができるようになります。
（NO Accept Serialization）
　次の話題なんですけど、一番最後のアクセプトのところですね。アクセプトのシリアライゼーションという話題があります。これは何かというと、クライアントが接続しに来たときに一斉に子プロセスを、ワーカーの子プロセスを起こしてしまうっていう、こういう問題があります。自分が接続を受け取るんだということで、それぞれのプロセスが起動してしまう問題ですね。最終的に起動するんですけど、実際受け取るのは1つです。
00：20：00
（Thundering Herd is an old story）
　あとはこのサンダリング・ハードっていうんですけど、この問題というのは完全に過去の問題ですね。〓ターンOS〓っていうか、〓カレの2.4〓の時代からなんですけど、OSが普通に1つしか起動しないようになってます。なのでサンダリング・ハードっていうのは起こりえないってのが最近のは入ってます。
　なので、アクセプト・シリアライゼーションってのは要らないよねっていうのが今の流れですね。ただ、Starmanなんかもそうなんですけど、いくつかのインターフェイスを同時に配分できるんですね。そういったときには何かしら別の方法で、どのインターフェイスについて何をするか、アクセプトするかっていうあたりでシリアライゼーションが必要になることもあります。Monocerosは実はしてないんですけども。
（TCP_DEFER_ACCEPT）
　次はTCPデファーアクセプト。これの解説をします。これは何かっていうと、さっきの〓ドレセツ〓はコケル瞬間のところですね。通常〓ハイフェイ〓のところに行けば接続のところだけエスタブリッシュな状態。接続を完了してTCPのハンドシェイクが終わった段階でアクセプトが起きるんですけど、そうではなくてデータが到着した。HTTPの〓イワレ〓で〓トアントワン〓と到着した段階で初めてアクセプトを起動するっていうことができます。
　これが何かっていうと、デフォルトの状態でクライアントAとBがあって、クライアントAがまずエスタブリッシュの状態になったところでアクセプトを起動します。で、実はクライアントAっていうのがずーっと、接続したはいいけど〓ベスト〓をなかなか送ってこないというので、ずーっと下側でブロック、〓ティーヨン〓の状態でブロックしてしまう。で、ようやくここ一番下で〓リクエスト〓が来たんでアプリケーションを実行してレスポンスを返す。で、次のクライアントBについてはそのあとに回されてしまうんですね。
　デファーアクセプトが入っているとどうなるかっていうと、アクセプトが、データが来ないとアクセプトが起動しないんで、ここが〓回路状〓になって、クライアントBから、実際に〓デッカ〓のリクエストが来たクライアントBから実行して、クライアントAがそのあとに実行されると。なので、〓アイドルタイム〓がある分だけ効率よくリクエストをさばくことができると。もちろんこのクライアントを〓エードロ〓してあげて、こっちの〓キャラクセル〓も処理することはできます。
　で、この、デファーアクセプトなんですけど、これStarletのコードから持って来たんですけど、実はLinuxしかサポートしてません。FreeBSDでは若干もうちょっと、HTTPのリクエストが完了されている。そしたらアクセプトはできないわけですけど、まあLinux、それとちょっとだけ違う例を書いたんですけど、Linuxの場合だけでこうやった例で。で、こっち9ですね。これ定数なんですけどStarletのコードこうなってるんですけど。たぶんまだ〓パード〓のソケットの〓ダイ〓のモジュールの中からそれをエクスポートする機能がないのかなあという感じです。
（timeout to read header）
　次、先ほども言った、タイムアウトする機能の実装ですね。
（alarm）
　方法いくつかあるんですけど、まず1つ目がアラームです。タイムアウトといったとき一番簡単なのがこの方法だと思います。で、実際キーワードの〓ボルク〓の中でシグナルのアラームをセットして、アラームでタイムアウトの秒数を指定して引用すると。それが中でもしタイムアウトになってしまったらタイムアウトの定数が入ってくるんで、それに加えてネクストで次のほうに〓ショウナン〓する。そうですね。あったら、そのリクエストを処理する。次の段階に入っていきます。
（nonblocking + select）
　もう1つの方法がノンブロッキングにする、あとセレクトを使ってそれを待つ。
　これもまたStarletのコードなんですけど。Starletのコードじゃないや。まあStarletのコードを簡略化したものなんですけど、アクセプトしたコネクションでのブロッキング「0」でノンブロッキングの状態にします。これによってリードかけたりライトをかけたりするときに、それらができないときに、普通ブロッキングだとリードをかけて実際データが来てないとずーっとそのリードのところで止まってしまうんですけど、ノンブロッキングになってるとリードをかけてデータが来てなければすぐに〓パート〓のほうに行ってまだデータが来てないという状態に戻せるようになります。それを使うんですけど。
00：25：00
　これをまず、〓ダイドウ〓セレクトを使ってリードができるようになるまで待つよっていうので、これリードタイムアウトっていうのを使ってます。で、指定したリードタイムアウトの秒数の中で〓テイク〓が実際データが来れば〓レジ〓の中に入ってくるんですけど、そうじゃなくて空っぽだったらというので次に行きます。もし空っぽだったら次の文字までデータを読んでリクエストを処理する流れになります。
（alarm vs. nonblocking + select）
　アラームとノンブロッキング・セレクト、〓いったんは増えます〓。Starmanは〓上〓です。Starletは下なんですけど、どちらがいいかということなんですけど、ひとつの〓基準〓としてシステムコールが少ないほうがいいと思います。
（Fewer syscalls is good）
　システムコールって何かというと、普通のWebアプリケーション、ユーザーの、ユーザーのコードからハードウェアに対して直接命令を送ったりするのは難しい。なかなかできないようになっているのが普通のOSです。その代わりシステムコール、OSに対して命令を送ってそれらが〓上に〓来るようにしながら、通信をしたり、ファイルの操作をしたりします。そんなシステムコールがすごいたくさんあるんですけど、今まで例に出てきた中ではリッスンだとか、オーボーだとか、リード、ライト、セレクト、全部システムコールです。
（alarm）
　アラームの場合どういうふうなことになるかというと、実際9回も、1回のリードをする間だけで9回もシステムコールが発行されます。ローカルシグアラームなんですけど、その部分が一番上ですね。なんかシグナルっぽい操作で、シグの中でシグナルなんかを指定してやります。さらに4行目も〓ツメマル〓なんで、実際に●が走ってると。で、ローカルシグナルなんで、そのブロックが終わると、それは削除されますね。その削除の作業というのがリードの下の3つです。デフォルト状態に戻して最後にやってる。これが9回になります。
（nonblocking + select）
　ノンブロッキングとセレクトする場合ってのは実際、4回ですね。
　一番上の〓ホントに必要になるの2万語なんですけど〓、ノンブロッキングを〓エフコントロール〓に対して、ノンブロッキングを指定してセレクトしてという。たったこれだけになります。
　なので、たぶんこっち側のほうが動かす効率がいいっていうのは言えます。
（Parse a request with “C”）
　次の話題なんですけど、リクエストを、HTTPのリクエストをCで回すという話です。
　これは一番簡単で、HTTPパーサーXS、これも〓カズノ〓さんのモジュールなんですけど、これを入れるとPlack HTTPサーバー、それを使っているので〓効率が良くなります〓。
（TCP_NODELAY）
　次、リクエストを処理してレスポンスを返す部分ですね。その話なんですけど、TCPノーディレイというふうに書いてます。
　TCPっていうのは、なんのか〓WIOD〓っていいますかね、これがデフォルトで動いていて、速度には影響っていうのはない。ライト、〓スクリプタ〓に対してライトを送ってもすぐにそれを獲得して飛んで行かないようになってます。
　図にするとこんな感じですね。ライト・フー、バーってしてもそれがしばらくの間、200ミリセックなんですけど、ファイリングされて1つの塊りとしてインターフェイスのほうに送られます。なのでこのファイリングする分だけ〓コウジョウトップ〓が遅延してしまうんですね。〓効率〓対応などでも、1つの物体にまとまるので効率は良くなるけど遅延してしまうと。
　TCPノーディレイを指定すると、ライトとライト同士に〓カケフードかけるとこ〓に飛んで行って、〓ライトパーシューの前にパーミット〓に飛んでいくと。こういうふうになってます。ただこれを多用しすぎるとTCPのパケットのカスがすごいことになってしまって、逆にそれも効率が悪くなる原因になる。
　どうするかっていうと、一番簡単なのは、アプリケーションの中でまずコンテンツをジョインしてひとつの塊にして1回で送る、そのほうが確実です。
（Write in once join content Server）
　とりあえずそれとなく、書いてますけど、重要なのは一番下で、ヘッダーのラインとボリュームコンテンツを全部分類して、1回の〓シスライト〓で書き出している。こうすることによって1回のパケットの中で全部が書き出されるんで、〓こっからこうして〓、さらにTCPノーディレイも効いてるんで、遅延なくリクエストの状態がストアできる。こういうふうな工夫が入っています。
（accept4, writev）
　この〓サンネンツキ〓ではちょっと詳しくは述べないんですけど、accept4（アクセプトフォー）っていうのが、先ほどのTCPノーコードっていうんですかね。あれをアクセプトしてコントロール、〓シンルイ〓のノンブロッキングを指定するんですけど、それを全部アクセプトの中で指示を1回で済ませるのがaccept4です。
00：29：50
　writev（ライトブイ）っていうのになると、〓デッカラタイオー〓っていうモジュールとか、〓ナイオウベクター〓とかっていうモジュールでサポートされてるんですけど、配列をそのまま渡すことができるんですね。なので、レスポンスの配列をそのまま渡すとそれを全部、whileで回すことなく1回のシステムコールの中で送り出すことができるものがあります。
　ただ、あんまりまだサポートされてないですね。accept4については確かCPANモジュールの中でもまだないです。こういうことでパフォーマンスがたぶん上がる。一番〓ココタキ〓たいんですけど、上がるサーバーを期したいと思います。
（Choose PSGI/Plack Server）
　ここから最後のほうになりますけど。実際にCPANに上がっているサーバーの選び方ですね。これをちょっと〓インブン〓的に話します。CPAN、いっぱい結構あります。Plackハンドラナントカっていうので検索すると、おそらくゴマンといっぱい出てきます。その中でたぶん普通に使うだろうなっていうのをいくつか紹介していきます。
（スタンドアロン）
　まずスタンドアロンですね。PlackハンドラースタンドアロンまたはPlackハンドラHTTPサーバーPSGIかな。長いですね。
　これは何かというと、plackupしたときに〓カイマイスウ〓でサーバーを指定しなければ自動的に起動するモジュールです。先ほど一番最初にさっき作った、一番最初の状態にほぼ近い、シングルプロセスで起動するサーバーです。このへんをサンプルで使うことが多いと思います。
（Starman）
　次、Starmanですけど、プリフォーク型のWebサーバーです。HTTP1.1、HTTPSもサポートしています。ほかのGSGIサーバーにはない特徴として、マルチプルインターフェイスですね。この辺に対応しています。いくつかの、このポートとこのポートとこのポートとをunixドメインのサーバーを同時にリッスンすることができます。あとサーバースターターを利用したホットデプロイもサポートされています。
（Starlet）
　Starletなんですけど、これブログでも使っているサーバーなんですけど、プリフォーキングのサーバーで、HTTP1.1に最新のモジュールで対応しました。作者は〓カズノ〓さんですよね。サーバースターターを利用してホットデプロイができます。
　どこが一番いいのか結構話題になるんですけど、Starmanっていうのはネットサーバーっていうモジュールをベースに使ったものです。ネットサーバーっていうのは結構難しいモジュールで、何か調べようと思ったとき結構難解なんですけど、Starletっていうのはほとんど〓テライチ〓でできてます。シンプルにできてて、しかも先ほどのチューニング、僕が話してきたチューニングってのは全部入ってるんで、かなり高速に動きます。
（Monoceros）
　次なんですけどMonoceros、先ほどお話ししたんですけど、HTTP1.1をサポートしています。Starletをベースにしてるのでやはり先ほどのチューニングっていうのは全部入ってて、高速に動きます。
（Twiggy）
　ちょっと毛色が違うTwiggy（ツイッギー）っていうPSGIサーバー。これエニーイベントでできてて、ノンブロッキングとストリーミング、非同期処理ができるようになってます。Twiggy自体はシングルプロセスで動きます。なのでマルチコールをきかせることができない。マルチコールを使わなくても、プロセスの中でいろいろ通信をして、チャットを作ったりだとかという中ではこれを使うしかないですね。
（Twiggy::Prefork）
　Twiggyをマルチプロセスに対応させたのがTwiggy::PreforkというPSGIサーバーです。これは何かっていうとTwiggyのアクセプトをする前に〓プライオリで〓プリフォークを使って子プロセスを起動するっていうことができるようになってますね。ノンブロッキングもストリーミングもサポートしながらマルチプロセスができます。先ほどの大量のアクセスに、1個以上の接続に対してどうやって対応するかっていうことを両方やっているモジュールになります。
（Feersum）
　次はちょっと毛色が違うFeersum（フィールサム）サーバーなんですけど、EV/libev（イーブイ・リブブイ）っていうのは、イベント処理のEポートだとかっていうのを隠蔽するモジュールに類するライブラリで、それをベースにして作られているPSGIサーバーです。たぶんですけど、ベンチマークそんなに詳しく打ってないですけど、たぶん一番速いと思うんですこれが。いくつかあるサーバーの中では一番速く〓ネーク〓動きます。もちろんEVとかlibev使っているので動きがそういう意味で非常に〓処理タイム〓です。知らなかったんですけど、調べてみたらマルチプロセスもできます。いくつか〓ノード〓を起動することもできます。ただ試したことはないんでなんすけど。あと〓イスポン〓、われわれのイスポンという●なんですけど、これを〓ジムエイシャのイチ〓がこれを使いました。
00：35：15
（How to Choose PSGI Server）
　いくつかサーバーを紹介してきたんですけど、これらどうやって選ぶかというのが次の話です。
　簡単に図にまとめるとこんな感じですね。1行目がCPUを使う処理、テンプレートだとかSQLだとか〓キャッシュ〓だとかっていう、わりとCPUを使う処理っていうのをする場合は上です。イベントドリブンする起動〓キャリア〓が必要なものは下になります。
　シングルプロセスとマルチプロセスっていう違いがあって、1つのプロセスの中に全部を入れなくちゃいけない場合は左側で、いくつかあるプロセスの中で〓ネットのイコート〓ってのは右側ですね。あとプリフォーク型についてはもちろんシングルプロセスでやる意味はないので全部右側になります。こんな感じで選んでもらったらいいかなって思うんですけど、基本的には右上か左下かのどっちかなのかなってのは思います。
（Finding Bottlenecks of Performance）
　これが最後の話題です。今PSGIサーバーいろいろあって、それがまああるんですけど、そのボトルネックですね。どうやって使うか。チューニングするときにボトルネックをどうやって見つけるかなんですけど。
（use Devel::NYTProf）
　1つ目がデベルNYTプロフを使うっていう方法です。最近のバージョンでフレームグラフっていうのをサポートしてる。これがすごい素晴らしいんですけど。これ、Starmanを起動して、〓出力ログ〓とかもいろいろ入っている状態で、あまり〓キョウリトウェイト〓を掛けた状態なんですけど。この上の段との差が大きいところっていうのは何かしらの処理をして時間が掛かっているので。で、そこを探してチューニングをしていくことになります。
（Flame Graph is awesome）
　〓デモプラン〓でいくつかプロセスが上がってるんで、それをどのプロセスIDなのかってまず見つけて、ntyprof.out.{PID}っていうのが、今たぶん〓出力したもの〓の中に入れておいたら対応できるので、それをnytprofhtmlで解析して見ます。アウトをかけてもファイルを見ても、親プロセスの情報しか入ってきてないので、実際リクエストを受けてないなんて〓例みたいなシーン〓になります。
（use strace or dtruss trace syscalls）
　もうひとつっていうのが、strace（sトレース）とdtruss（dトラス）っていうコマンドですね。dtrussっていうのがコールサインになっています。これは何をするかというと、システムコールですね、これをトレースするわけです。
　使い方はこんな感じですね。よく使うオプションがこんな感じなんですけど、「-tt」っていうのが時間〓係数〓で、「-s 200」ってのが200バイト〓書き出す〓、「-p」でpidを指定してそれを。
　ただstraceってのも、これもエラーとともに全部返ってしまうので、〓配布リリース〓とかって見ることができないんですね。こんなで、表示エラーを表示してるのを配布して、さらにファイルに書いてあとで〓よーく〓見てたりします。
　出力するとこんな感じです。僕すごいこれ見慣れててだいたい分かるんですけど。アクセプトしたあとに、なんかIOコントロールだとかLCだとかあの辺なんかすごい無駄っぽいなみたいなことが、僕は分かるんですけどどうなんでしょうね。
　だいたいなんか、キャプチャした中に〓データイチビー〓だとか、ライトで〓イチビ1年200億円〓とか書いてると、だいたいその辺から探すといいなと思います。
（in conclusion）
　はい、まとめでーす。PSGIサーバーはとても速くなりました。最初にベンチマークの値で見たとおり、半年前に比べてだいたい2倍くらいの速度になってます。案件にもよるんですけど、Starletで最大15万リクエスト／セックまで出せることは可能で確認してます。なのでPSGI/Plackとても速いし安定してます。すばらしいですね。
　その中でもいくつか問題があったりとかした場合は、RT、Git Hub Issue、Pull Reqs、あるいはIRCだとか、あと〓ハッシンダン〓とか●とか、僕のほうまで何かメッセージで送ってもらうと何か〓問題〓探したりするかもしれません。ザッツ終わりでーす。ありがとうございました。
司会：はい、カゼブロさんありがとうございました。時間いっぱいなので質問の時間は取りません。何か質問のある方は個別に質問してください。ありがとうございました。
00：40：11
