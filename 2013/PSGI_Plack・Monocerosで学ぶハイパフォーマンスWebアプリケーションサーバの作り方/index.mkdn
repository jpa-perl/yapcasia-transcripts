　はい、じゃあ始めまーす。「PSGI/Plack・Monocerosで学ぶハイパフォーマンスWebアプリケーションサーバーの作り方」ということで喋ります。
　



　
　軽く自己紹介なんですけど、長野雅広といいます。IDがkazeburoなので、社内でkazeburoさんと呼ばれています。オペレーション・エンジニアです。運用エンジニアをやっていて、LINEで働いてます。先ほどの櫛井さんと一緒で、グループにいて、LINEの、LINEなんとかっていうサービス会社やライブドアの関連の開発支援をしています。　



　
　
　ライブドアなんですけれども、ライブドアブログが今年12月で10周年だそうです。10年前に何をやってたか覚えてないですけど、10年経ってます。今のライブドアブログは、Perlの5.16で動いてます。あとごくごく一部でまだ5.8が動いてますね。で、デプロイなどのCartonをもう使い始めてます。Cartonの1.00を使っております。あとPSGI、Plackももちろん使っていて、過去にはmod_perlも使ってましたけど、メインのところはだいたいこのコードが担当しています。これはスタッフのブログなんですけれども、リクエストのヘッダーを見ていただくと、「Plack::Handler::Starlet」と出てきているはずです。　



　
　
　このStarletは、何台かっていうのはちょっと言えないでんすけど、今は1日でだいたい10億リクエストぐらいを捌いています。10億リクエストですね。HTMLだけじゃなくて、JSONだとか、動的に作成したJSを含んだ値です。　



　
　
　この10億／デイリーのアクセスを捌くために、いろんなレイヤーでのパフォーマンスのチューニングっていうものを毎日やっていかないといけないし、どうしても1ページ当たりのコストを下げないといけないので、そういった挑戦をしています。どんなレイヤーがあるか軽く書き出すとこんな感じで、上から下まであるんですけど、このアプリケーションサーバーのレイヤー、これが今日のお題です。　



　
　
　ところで、”Open & Share”とライブドアの時代からずっと言ってるんですけど、たくさんのCPANとオープンソースのソフトウェアを使っているし、貢献もしています。
　ライブドアブログのパフォーマンスを上げているっていうことが、そのままたぶんPlackだとかPSGI、StarletだとかCPAN上のモジュールのパフォーマンスを上げていくっていう、そういうことだと思っています。
　左側なんですけど、われわれがまだmod_perlを使っていた時代から、半年くらい前と今一番新しいモジュールのバージョンでパフォーマンスを比べると、これだけの差が出てきています。倍ですね。いろんな工夫をしている中で、こういうことが起きてました。
■Monoceros
　その次の話題なんですけど、Monoceros（モノセロス）のサーバーを、3〜4ヶ月前からずっと作っています。これはPSGIのサーバーで、実験的な機能もあるんですけど、パフォーマンスを出すために作られたWebサーバー、PSGIサーバーです。
　どんなことを目標としてるかというと、TCPのスリーウェイ・ハンドシェイクで、TCPの接続のためのコストを下げることです。どこのTCPの接続かっていうと、リバースプロキシーとPSGIのサーバーとの間がメインの狙いです。
　通常、リバースプロキシーとサーバーはどうやって通信してるかというと、まずTCPの接続を作るために専用ルーターを書いて、遅延アプリを取り除いて、TCPのセキレイの支援を行ってようやく接続を完了して、デートリクエストを送ってレスポンスをもらっているんです。レスポンスが終わったらだいたいこのようなところで接続が切れて、次のリクエストのときには支援が増えているので、もう一度接続して直さないといけない。パフォーマンスを出さなくちゃいけない、リクエストが大量に来ている中ではこれがボトルネックになることがあります。
■Keep Alive
　だからもういろんな工夫をしなければいけないんですね。HTPP1.0/1.1には、そもそもKeep Alive（キープアライブ）という機能があります。これは何かというと、一度接続したときに、1.0だったらいったん"Connection: Keepalive"っていうヘッダを送って、appサーバーからコネクションキープアライブが返ってきて、1.0の場合はコンテンツの中だというのが返って、どこでそのコンテンツが終了するのかを決めて、このコンテンツの終了までを読み終わったら次のリクエストを送っていいという状態にしたうえで、どこのコンテンツに送っても接続を確認していこうというものです。HTTP 1.1の場合はTransfer EncodingにChunked Transferっていうのがサポートされていて、デフォルトでキープアライブを送ります。
■C10K problem
　ただ、これを使えばいいかというと、ここにも問題があります。いわゆるC10K（シーテンケー）問題ですね。コネクションを大量に張ったときにどう動くかという問題です。
　昨日発表した方の中にも、「Apacheを使っているのはもう古い人」とか言っていた人がいたんですけど、nginxのわり方も、デフォルトでもうコネクションをいっぱい張っても大丈夫なような設定になっています。ただ、その、コネクションをいっぱい張っている状態から、appサーバーに向かってキープアライブのリクエストを大量に張ると、appサーバーは当然詰まります。
　なぜかというと、Preforkモデルでは、1コネクションにつき1プロセスが占有されるという問題があるのです。
　Starmanの場合はデフォルトで5プロセス、Starletだと10プロセス上がるんですけど、これが一致しないとこの5つのコネクションでいっぱいになってしまうし、Starletも5つのコネクションでいっぱいになります。例えば100個とか200個くらいまでだったら直接上げることはできますけど、プロセスを1,000個、2,000個と上げると、それはもうボトルネックになって、負荷の原因になってしまいます。
　それに対して、Monocerosはプリフォーキングのモデルなんですけど、コネクションをいっぱい張れるという面白い特徴を持っています。
　どういった仕組みなのかというと、まずクライアントが普通に●●されたワーカープロセスに向かってリクエストを送り、処理してレスポンスを返したあとに、これをマネージャーのプロセスに返します。後ろでずっとストラッカプロセスがUNIXドメインの通信をしていて、マネージャーを通してそこで監視します。ここでケントトウループで監視していて、クライアントからキープアライブの次のリクエストが来たら、このソケットをこの空いているバッファに渡し、そこでリクエストを処理してレスポンスを返すという仕組みになっているので、コネクションによってプロセスが占有されることがない構造になっています。
　このワーカーは、このままユースケーススタディとしてあって、そのまま一般に使うことはできないんですね。ただ、イベントドリブンでできているこのマネージャープロセスっていうのが、エニーイベントでできているので、それ以降はそういった仕組みになっています。
　ベンチマークについては、通常のAPの、例えばバッチベンチなところは、接続を張れば、コネクションを使って大量のリクエストを送るというベンチマークになっていて、たくさんのブラウザがある状態から大量のリクエストが来るっていう状況を再現できないんですね。
　それを再現するときにちょっと別のプログラムを作って、接続して何かのリクエストを送って、キープアライブがタイムアウトで切れるまでそのリクエストを放置するっていうベンチマークをすると、左側がStarletでMonocerosが右側で、トータルタイムが54秒と8で6秒と5倍くらい速いです。しかもリクエストの失敗もなくて、タイムアウトすることがありません。Monocerosには、大量のリクエストを送ってるけど、プロセスがそのスリットを受け取ってくれないからタイムアウトして失敗するということがないという特徴があります。
　Monocerosのバージョンは、僕が結構頻繁に上げているんですけど、だいたい安定しているんじゃないかなあと思ってます。なので、プロダクションでぜひ使ってみてください。
■Plack/PSGI Basic
　今まで散々PlackだとかPSGIって言ってたんですけど、そもそもそれって何だっけっていうことをこれから話します。
　結構口酸っぱく言われてると思うんですけど、PSGIというのは仕様です。Plackっていうのは、そのPSGIの仕様をインプリメント、実装したものです。ではPSGIとは何かというと、アプリケーションをサブルーチンで表現して、env（エンブ）を受け取ってレスポンスを返すというものです。
　envには何が入っているかっていうと、CGIの時代からやってた方はよくご存知のこの、ちいちゃい、いわゆるkey。ハッシュのkeyですね。リクエストだとかHTTPなんとかっていうヘッダーの情報が入ってます。それに加えて、PSGIが使うバイセンだとかインプットとか、エラーのスタットが入ってます。
　レスポンスにはどういう形があるのかというと、まず一番オーソドックスな形なのがこれです。大きく分けて3つですね。一番最初がステータスコード、HTTPの、オッケーの200ですね。2番目がヘッダーで、これは大事な配列のリファレンスですね。最後は、配列の中に文字やコンテンツを入れるという形になっています。
　あとはちょっと別な形として、こういうIOハンドラもありますね。IOへフリ、IOタイプとかのオブジェクトを渡すこともできます。
　ここからは結構難しくなってくるので簡単に流すんですけど、いきなりレスポンスを返すんじゃなく、サブルーチンだけを返しておいて、その中で遅延させてレスポンスを返してやるとか、先にヘッダー文字だけ送ってレスポンスをさらに各処理に返していくっていうことも、PSGIの仕様の中ではサポートされています。
　では、PSGIのサーバーは何をするものなのかっていうことなんですけど、簡単に言えばenvを作って、アプリケーションを実行して、返ってきたレスポンスをもらって、それをプロトコルに合わせた形で出力するということですね。
　簡単に凝縮するとこんな感じです。
　Apacheだったら、CJケーリングだったりボットパーだったり、エンジンXでCJ、パースCJを使って、いろんなプロトコルでアクセスしてくるんですけど、最終的にはenvを作ってアプリケーションを実行して、ソフトをもらって、そのレスポンスの配列をプロトコルに合わせた形で整形して返してあげる。これがPSGIのサーバーの役割です。
　PSGIサーバーは、Plackハンドラって呼ばれることもあります。Plackサーバー、Plackハンドラって呼ばれたりもします。
　何が違うかっていうと、Plackハンドラっていうのは、PSGIサーバーとPlackとのインターフェイスです。簡単に言うと、PSGIサーバーをplackupで実行するためのADIです。
　スターマンStarman::Server（スターマン・サーバー）っていうモジュールがPSGIサーバーの実装で、Plack::Handler::Starman（プラック・ハンドラ・スターマン）っていうのがPlackハンドラという関係になっています。ですので、StarletでMonocerosのソースコードを切るときもだいたいこの形式になっていて、Starletサーバーがあって、Monocerosサーバーがあって、Plackハンドラがその2つとの間にあるという関係です。
■Make PSGI/Plack Server
　PSGIの仕様がだいたいわかったところで、ここからはPSGIのサーバーを実際ちょっと作ってみようという話です。スタンドアロンで動く簡単なWebサーバーを作ると、だいたいこんな感じです。細かく読まなくてもいいんですけど、60行ぐらいでだいたい動くハンドラができます。
■Listen and Accept
　ちょっとずつ見ていくと、リッスン（Listen）指定。そのソケットを受け取るところですね。IOソケットを使って5000番をリッスンして、何か新しいことが出たらヘッドをコネクトします。この前のアクセプト（accept）っていうところで、新しいソケットが来るのを新しい通信が来るまでブロックしてくれるので、こうやってホワイル（while）で回しておくと動くってことです。
■Read a request
　次の、リクエストを読むところっていうのがこんな感じです。ごにょごにょとenvを作るところだけ要するんですよ。envを作って、一番最後のパーセイHTTPリクエスト、これが、Plack HTTPパーソンっていうところから提供されるものなんですけど、HTTPのヘッダーをファンスファンスして、envのところに適当に打ち込んでくれる、そういうモジュールになってます。これがあるだけで、うちでWebサーバーを書くことがすごく簡単になってます。
■Run App
　その次、envができたのでアプリケーションを実行するところなんですけど、上のが一番簡単にプリミティブに書いた棒打ちをする感じですね。下はPlackカル辺りから提供されてる機能ですが、下の場合だとapp（アップ）を実行するところのトウロにイワロをかけて、さらにその中にエラーのレスポンスを作ってくれるところで入れてます。ですので、下を使ったほうがシンプルになります。
■Write a response
　最後、レスポンスを返すところですね。これも結構長いんですけど、やってることっていうのはヘッダーの配列をくるくる回して、レスポンスヘッダーを作っていって、最後にジスライトでそれを書き出すということです。ホイールのところの配列なんですけど、ぐるぐるジスライトで回して最後に通す。
　これで一応できて、サーバーやさっきのコードなんかも実行することができるんですけど、たぶん遅いです。ここで問題がいくつか出てきます。
■This PSGI Server has some problem
　問題は大きく分けると3つで、1つめは、さっきのプロセス1つなんて、通信リクエストを1つしか受けることができないんです。あと、タイムアウトがないので、Telnetでアクセスして放置しておくと、ほかのリクエストを一切受け取ることができないという問題もありますね。それから、あんまり速くもありません。
　なので、これをチューニングしていきましょうっていう話です。
■Increase concurrency
　まず、コンクレンシーですね。大量のアクセス、いくつかのアクセスを書いて出られるようにしようということです。
■Multi Process IO Multiplexing or Both
　方法はいくつかあるんですけど、1つめはマルチプロセスにすること。プロセスをいくつか立ち上げて、それらがリクエストを受ける形にします。または、1つのプロセスなんですけど、IO多重化によって1つのプロセスの中でいくつも通信を受けることができるようにすることもできるし、もしくは両方やる方法もあります。
■Preforking model
　IO多重化は結構面倒くさいし使い道も限られるので、ここで採用するのはプリフォーキングです。こっちのほうがシンプルにできるるのでスケーリングします。
　プリフォークのプロセスは、さっきのMonocerosのもすごく似ているんですけど、簡単に説明すると、まずデレクターでマネージャーの親プロセスでバインドしてリストにするところまでいきます。そのあと子プロセスをコウキしていって、その中でセイトウのところで止まっていくと。こういった動きをするのがプリフォーキングのモデルです。で、クライアントはそれぞれのところに通信をしていくものです。
　このプリフォーキングを使うには、バリヤクをどう動かすかが重要なんです。これを使うのが一番簡単です。これはプリフォークで、この場合マックスオータのところで5つバックアッププロセスを起動して、キューとかされたときにとまりえる感じでシグナルレシーブなんですけど、コステの中で、その動きの中でスタートというところで子プロセスを起動していきます。その中では役割の配分が入ってくる。これだけで、その子プロセスを起動するのに、5つまでコネクションができるようになります。
■NO Accept Serialization
　次の話題なんですけど、一番最後のアクセプトのところですね。アクセプトのシリアライゼーションという話題があります。これは何かというと、クライアントが接続しに来たときに、一斉にワーカーの子プロセスを起こしてしまうことがあります。自分が接続を受け取るんだということで、それぞれのプロセスが起動してしまう問題ですね。最終的に起動するんですけど、実際に受け取れるのは1つです。
■Thundering Herd is an old story
　あとはこのサンダリング・ハードっていうんですけど、この問題というのは完全に過去の問題ですね。ターンOSっていうか、カレの2.4の時代からなんですけど、OSが1つしか起動しないようになってます。だから、サンダリング・ハードは起こりえないってのが最近の認識です。
　なので、アクセプト・シリアライゼーションは要らないよねっていうのが今の流れです。ただ、Starmanなんかもそうなんですけど、いくつかのインターフェイスを同時に配分できるんですね。そういったときには何かしら別の方法で、どのインターフェイスについて何をするか、アクセプトするかっていうあたりでシリアライゼーションが必要になることもあります。実は、Monocerosはこれをしてないんですが。
■TCP_DEFER_ACCEPT
　次はTCPデファーアクセプトの解説をします。これは何かっていうと、さっきのドレセツはコケる瞬間のところで、通常、ハイフェイのところに行けば接続のところだけエスタブリッシュな状態で、接続を完了してTCPのハンドシェイクが終わった段階でアクセプトが起きるんですけど、そうではなくて、TCPデファーアクセプトでは、データがHTTPのイワレでトアントワンと到着した段階で、初めてアクセプトを起動することができます。
　デフォルトの状態でクライアントAとBがあると、クライアントAがまずエスタブリッシュの状態になったところでアクセプトを起動します。で、実はクライアントAっていうのが、接続したはいいけどなかなかベストを送ってこないというので、ずっと下側でティーヨンの状態でブロックしてしまいます。で、ようやくこの一番下でリクエストが来たんで、アプリケーションを実行してレスポンスを返すんですが、次のクライアントBについてはそのあとに回されてしまうんですね。
　デファーアクセプトが入っているとどうなるかっていうと、データが来ないとアクセプトが起動しないので、ここが回路状になって、実際にデッカのリクエストが来たクライアントBから実行して、クライアントAがそのあとに実行されることになります。つまり、アイドルタイムがある分だけ、効率よくリクエストをさばくことができるんですね。もちろんこのクライアントをエードロしてあげて、こっちのキャラクセルを処理することもできます。
　それで、このデファーアクセプトなんですけど、これはStarletのコードから持って来たんですが、実はLinuxしかサポートしてません。FreeBSDではもうちょっとHTTPのリクエストが完了されています。そしたらアクセプトはできないわけですけど、まあLinux、それとちょっとだけ違う例を書いたんですけど、これはLinuxの場合だけでやった例です。で、こっち9ですね。これは定数なんで、Starletのコードはこうなってるんですけど、たぶんまだパードのソケットのダイのモジュールの中からそれをエクスポートする機能がないのかなあという感じです。
■timeout to read header
　次は、先ほども言ったタイムアウトする機能の実装です。
■alarm
　方法はいくつかあるんですけど、まず1つめはアラームです。タイムアウトといったときに一番簡単なのは、この方法だと思います。実際にキーワードのボルクの中でシグナルのアラームをセットして、アラームでタイムアウトの秒数を指定して引用します。それがもしタイムアウトになってしまったら、タイムアウトの定数が入ってくるので、それに加えてネクストで次のほうにショウナンして、あったらそのリクエストを処理するというふうにして、次の段階に入っていきます。
■nonblocking + select
　もう1つは、ノンブロッキングにして、セレクトを使ってそれを待つという方法です。
　これはStarletのコードを簡略化したものなんですけど、アクセプトしたコネクションでのブロッキングを「0」として、ノンブロッキングの状態にします。これによってリードをかけたりライトをかけたりしようとしているけれどそれらができないときに、普通はブロッキングだとリードをかけて実際データが来てないとずーっとそのリードのところで止まってしまうんですけど、ノンブロッキングになってると、リードをかけてデータが来てなければすぐにパートのほうに行って、まだデータが来てないという状態に戻せるようになります。その仕組みを使っていきます。
　これをまず、ダイドウセレクトを使ってリードができるようになるまで待つために、リードタイムアウトっていうのを使ってます。で、指定したリードタイムアウトの秒数の中で、実際にデータが来ればテイクがレジの中に入ってくるんですけど、そうじゃなくて空っぽだったらという仮定で次に行きます。もし空っぽだったら、次の文字までデータを読んでリクエストを処理する流れになります。
■alarm vs. nonblocking + select
　アラームとノンブロッキング・セレクトは、いったんは増えます。Starmanは上、Starletは下です。どちらがいいかというと、ひとつの基準としては、システムコールが少ないほうがいいと思います。
■Fewer syscalls is good
　普通のOSでは、Webアプリケーションでユーザーのコードからハードウェアに対して直接命令を送ったりするのは難しくて、なかなかできないようになっています。その代わり、システムコールがOSに対して命令を送って、それらが上に来るようにしながら、通信をしたり、ファイルの操作をしたりします。そんなシステムコールがすごいたくさんあるんですけど、今まで例に出てきた中ではリッスンだとか、オーボーだとか、リード、ライト、セレクト、これらは全部システムコールです。
■alarm
　アラームの場合にどういうことになるかというと、実際、1回のリードをする間だけで9回もシステムコールが発行されます。ローカルシグアラームなんですけど、その部分が一番上ですね。シグナルっぽい操作で、シグの中でシグナルを指定してやります。さらに4行目もツメマルなんで、実際に●が走ってます。で、ローカルシグナルなんで、そのブロックが終わると、それは削除されますね。その削除の作業というのがリードの下の3つです。デフォルト状態に戻して最後にやってるんですが、これを9回やっています。
■nonblocking + select
　実際にノンブロッキングとセレクトする場合は、4回ですね。
　一番上のホントに必要になるのは2万語なんですけど、ノンブロッキングをエフコントロールするのに対して、ノンブロッキングを指定してセレクトするという、たったこれだけです。
　なので、たぶんこっち側のほうが効率よく動かすことができます。
■Parse a request with“C”
　次の話題は、HTTPのリクエストをCで回すという話です。
　これは一番簡単で、HTTPパーサーXS、これもカズノさんのモジュールなんですけど、これを入れるとPlack HTTPサーバーを使っているので効率が良くなります。
■TCP_NODELAY
　次は、リクエストを処理してレスポンスを返す部分ですね。その話なんですけど、TCPノーディレイというふうに書いてます。
　TCPっていうのは、WIODがデフォルトで動いていて、速度には影響はありません。スクリプタに対してライトを送っても、すぐにそれを獲得して飛んで行かないようになってます。
　図にするとこんな感じですね。ライト・フー、バーってしてもそれがしばらくの間、200ミリセックなんですけど、ファイリングされて1つの塊としてインターフェイスのほうに送られます。なので、これをファイリングする分だけコウジョウトップが遅延してしまうんですね。効率対応などでも、1つの物体にまとまるので、効率は良くなるけど遅延してしまう。
　TCPノーディレイを指定すると、ライトとライト同士にカケフードかけるところに飛んで行って、ライトパーシューの前にパーミットに飛んでいくというふうになっています。ただ、これも多用しすぎるとTCPのパケットのカスがすごいことになってしまって、逆に効率が悪くなる原因になってしまいます。
　結局どうするかというと、一番簡単なのはアプリケーションの中でまずコンテンツをジョインしてひとつの塊にして1回で送るほうが確実だと言えます。
■Write in once join content Server
　それとなく書いてますけど、重要なのは一番下で、ヘッダーのラインとボリュームコンテンツを全部分類して、1回のシスライトで書き出しているところです。こうすることによって全部1回のパケットの中で書き出されるし、さらにTCPノーディレイも効いているので、遅延なくリクエストの状態がストアできるという工夫がされています。
■accept4, writev
　このサンネンツキでは詳しくは述べないんですけど、先ほどのTCPノーコードをアクセプトしてコントロールしてシンルイのノンブロッキングを指定するんですけど、それを全部アクセプトの中で指示を1回で済ませるのがaccept4（アクセプトフォー）です。
　writev（ライトブイ）っていうのになると、デッカラタイオーとかナイオウベクターとかっていうモジュールでサポートされてるんですけど、配列をそのまま渡すことができるんですね。なので、レスポンスの配列をそのまま渡すと、whileで回すことなく、それを全部1回のシステムコールの中で送り出すことができます。
　ただ、あんまりまだサポートされてないですね。確か、accept4についてはCPANモジュールの中でもまだサポートがないです。たぶんこういうことでパフォーマンスが上がるので、一番ココタキたいんですけど、上がるサーバーを期したいと思います。
■Choose PSGI/Plack Server
　ここから最後のほうになりますけど、実際にCPANに上がっているサーバーの選び方をちょっとインブン的に話します。CPAN、結構いっぱいあります。Plackハンドラナントカっていうので検索すると、おそらくゴマンと出てきます。その中でたぶん普通に使うだろうなっていうのをいくつか紹介していきます。
■スタンドアロン
　まずスタンドアロンですね。PlackハンドラースタンドアロンまたはPlackハンドラHTTPサーバーPSGIかな。長いですね。
　これは何かというと、plackupしたときにカイマイスウでサーバーを指定しなければ自動的に起動するモジュールです。最初に作った状態に近いシングルプロセスで起動するサーバーです。このへんをサンプルで使うことが多いと思います。
■Starman
　次のStarmanは、プリフォーク型のWebサーバーです。HTTP1.1、HTTPSもサポートしています。ほかのGSGIサーバーにない特徴として、マルチプルインターフェイスに対応しています。いくつかの、このポートとこのポートとこのポートとunixドメインのサーバーを同時にリッスンすることができます。それと、サーバースターターを利用したホットデプロイもサポートされています。
■Starlet
　Starletはブログでも使っているサーバーなんですけど、プリフォーキングのサーバーで、最新のモジュールでHTTP1.1に対応しました。作者はカズノさんですよね。サーバースターターを利用してホットデプロイができます。
　どこが一番いいのか結構話題になるんですけど、Starmanはネットサーバーというモジュールをベースに使ったものです。ネットサーバーは結構難しいモジュールで、何か調べようと思ったとき結構難解なんですけど、Starletはほとんどテライチでシンプルにできていて、しかも先ほどから僕が話してきたチューニングは全部入ってるので、かなり高速に動きます。

■Monoceros
　次はMonocerosで、先ほどお話ししたとおり、HTTP1.1をサポートしています。Starletをベースにしてるので、やはり先ほどのチューニングは全部入ってて、高速に動きます。
■Twiggy
　ちょっと毛色が違うTwiggy（ツイッギー）っていうPSGIサーバーなんですが、これはエニーイベントでできていて、ノンブロッキングとストリーミング、非同期処理ができるようになっています。Twiggy自体はシングルプロセスで動きます。なので、マルチコールをきかせることができません。マルチコールを使わなくても、プロセスの中でいろいろ通信をして、チャットを作ったりするにはこれを使うしかないですね。
■Twiggy::Prefork
　Twiggyをマルチプロセスに対応させたのが、Twiggy::PreforkというPSGIサーバーです。これは、Twiggyのアクセプトをする前に、プライオリでプリフォークを使って子プロセスを起動することができるようになってますね。ノンブロッキングもストリーミングもサポートしながらマルチプロセスができます。先ほどの大量のアクセスに、1個以上の接続に対してどう対応するかということを両方やっているモジュールになります。
■Feersum
　次はちょっと毛色が違うFeersum（フィールサム）サーバーです。EV/libev（イーブイ・リブブイ）っていうのは、イベント処理のEポートとかを隠蔽するモジュールに類するライブラリで、それをベースにして作られているPSGIサーバーです。ベンチマークはそんなに詳しく打ってないですけど、たぶんこれが一番速いと思うんです。いくつかあるサーバーの中では、一番速くネークが動きます。もちろんEVとかlibevを使っているので、そういう意味では動きが非常に速いです。調べてみたらマルチプロセスもできますし、いくつかノードを起動することもできます。ただ試したことはないんであれなんですけど。あとイスポン、われわれのイスポンという●なんですけど、ジムエイシャのイチがこれを使いました。
■How to Choose PSGI Server
　いくつかサーバーを紹介してきたんですけど、どうやってこれらを選ぶかというのが次の話です。
　簡単に図にまとめるとこんな感じですね。1行目がCPUを使う処理で、テンプレートだとかSQLだとかキャッシュだとかっていう、わりとCPUを使う処理をする場合は上です。イベントドリブンする起動、キャリアが必要なものは下になります。
　これにはシングルプロセスとマルチプロセスっていう違いがあって、1つのプロセスの中に全部を入れなくちゃいけない場合は左側で、いくつかあるプロセスの中でネットのイコートは右側ですね。あと、プリフォーク型については、もちろんシングルプロセスでやる意味がないので全部右側になります。こんな感じで選んでもらったらいいかなって思うんですけど、基本的には右上か左下かのどっちかなのかなって思います。
■Finding Bottlenecks of Performance
　これが最後の話題です。今はPSGIサーバーがいろいろあるんですけど、ボトルネックがありますね。これをどうやって使うか、チューニングするときにボトルネックをどうやって見つけるかなんですけど。
■use Devel::NYTProf
　1つめが、デベルNYTプロフを使う方法です。最近のバージョンで、フレームグラフというのをサポートしています。これがすごく素晴らしいです。これはStarmanを起動して出力ログとかもいろいろ入っている状態で、キョウリトウェイトをかけた状態なんですけど、この上の段との差が大きいところは何かしらの処理をして時間がかかっているので、そこを探してチューニングをしていくことになります。
■Flame Graph is awesome
　デモプランでいくつかプロセスが上がってるので、それがどのプロセスIDなのかをまず見つけます。たぶん、出力したものの中に入れておいたらntyprof.out.{PID}が対応できるので、それをnytprofhtmlで解析して見ます。アウトをかけてもファイルを見ても、親プロセスの情報しか入ってきてないので、実際リクエストを受けてないなんて例みたいなシーンになります。
■use strace or dtruss trace syscalls
　もうひとつは、strace（sトレース）とdtruss（dトラス）っていうコマンドですね。dtrussっていうのがコールサインになっています。これは何をするかというと、システムコールをトレースするわけです。
　使い方はこんな感じですね。よく使うオプションがこんな感じなんですけど、「-tt」っていうのが時間係数で、「-s 200」ってのが200バイト書き出す、「-p」でpidを指定して。
　ただstraceもエラーとともに全部返ってしまうので、配布リリースを見ることができないんですね。表示エラーを表示してるのを配布して、さらにファイルに書いてあとでよーく見てたりします。
　出力するとこんな感じです。アクセプトしたあとに、IOコントロールだとかLCだとかあのあたりが無駄っぽいなみたいなことが、僕は分かるんですけどどうなんでしょうね。
　キャプチャした中にデータイチビーだとか、ライトでイチビ1年200億円とか書いていたら、だいたいその辺から探すといいなと思います。
■in conclusion
　はい、まとめでーす。PSGIサーバーはとても速くなりました。最初にベンチマークの値で見たとおり、半年前に比べてだいたい2倍くらいの速度になっています。案件にもよるんですけど、Starletで最大15万リクエスト／セックまで出すことは可能だと確認してます。PSGI/Plackはとても速いし、安定してます。素晴らしいですね。
　その中でもいくつか問題があったりとかした場合は、RT、GitHub Issue、Pull Reqs、あるいはIRCだとか、あとハッシンダンとか●とかで、僕まで何かメッセージを送ってもらうと、問題を探したりするかもしれません。ザッツ終わりでーす。ありがとうございました。






nagano2013
YAPC：Asia Tokyo 2013におけるトーク。
PSGI/Plack・Monocerosで学ぶ
ハイパフォーマンスWebアプリケーションサーバーの作り方

00：00：00
長野：はいじゃあ始めまーす。「PSGI/Plack・Monocerosで学ぶハイパフォーマンスWebアプリケーションサーバーの作り方」ということで喋ります。

軽く自己紹介なんですけど、長野雅広といいます。IDとかkazeburoというんで、社内でkazeburoさんと呼ばれています。オペレーション・エンジニアです。運用エンジニアをやっていて、LINEで働いてます。先ほどの櫛井さんといっしょで、グループにいて、LINEの、LINEなんとかっていうサービス会社、ライブドアの関連のところの開発のサポートですね、開発支援をしています。

![](http://30d.jp/img/yapcasia/6/280_large.jpg "(c) Japan Perl Association")

ライブドアなんですけれども、ライブドアブログが今年12月で10周年だそうです。10年だそうです。10年前何やってたか覚えてないですけど、10年経ってます。このライブドアブログなんですけど、今Perlの5.16で動いてます。あとごくごく一部でまだ5.8が動いてますね。で、デプロイなどのCartonをもう使い始めてます。Cartonの1.00を使っております。あとPSGI、Plackももちろん使っていて、過去にはmod_perlのほうも使ってましたけど、メインのところはだいたいこのコードが担当しています。これスタッフのブログなんですけれども、リクエストのヘッダーをですね、見ていただくと「Plack::Handler::Starlet」と出てきているはずです。

このStarlet、今だいたい1日で10億リクエストぐらいさばいてます。何台かっていうのはちょっと言えないでんすけど。10億リクエストですね。HTMLだけじゃなくてJSONだとかそういった、JS、動的に作成したJSを含んだ値です。

この10億／デイリーのアクセスをさばくために、いろんなレイヤーでのパフォーマンスのチューニングっていうものを毎日やっていかないと、さばくことができないし、1ページ当たりのコストというのをどうしても下げないといけないんで、そういった挑戦をしていると。どんなレイヤーがあるかというと、軽く書き出すとこんな感じで、上から下まであるんですけど、今日の話す内容っていうのはこのアプリケーションサーバーのレイヤーですね、これが今日のお題です。

ところでなんですけれども、Open & Shareっていうのを、ライブドアの時代からずっと言ってることなんですけど、たくさんのCPANとオープンソースをソフトウェアを使ってるし、貢献もしています。

ライブドアブログのこのパフォーマンスを上げているっていうことが、そのままたぶんPlackだとかPSGI、StarletだとかCPAN上のモジュールのパフォーマンスを上げていくっていう、そういうことだと思っています。

われわれが、左側なんですけど、まだmod_perlを使っていた時代から、半年くらい前ですけどそういう形で今一番新しいモジュールのバージョンでパフォーマンスを比べると、これだけの差が出てきてます。倍ですね。いろんな工夫をしていっている中でこういうふうなことが起きてました。

## Monoceros

その次の話題なんですけど、Monoceros（モノセロス）のサーバーを、どのくらい前からな、3、4ヶ月前からずっと作っていってます。これは何かというと、PSGIのサーバーで、実験的な機能もあるんですけど、パフォーマンスを出すために作られたWebサーバー、PSGIサーバーです。

どんなことを目標としてるかって言うと、TCPのスリーウェイ・ハンドシェイクですね、TCPの接続のためのコストを下げようっていう。どこのTCPの接続かっていうとリバースプロキシーとPSGIのサーバーとの間がメインの狙いです。


通常、リバースプロキシーとサーバーはどうやって通信してるかっていうと、まずTCPの接続を作るために専用ルーターを書いて、〓遅延アプリを取り除いて〓、TCPの〓セキレイの支援〓を行なってようやく接続を完了して、〓デート〓リクエストを送ってレスポンスをもらう。レスポンスが終わったらだいたいこのようなところで接続が切れて、次のリクエストのときには〓支援〓が増えている。一度接続をして直さないといけない。これっていうのは、パフォーマンスを出さなくちゃいけない、リクエストが大量に来ている中ではこれがボトルネックになるということがあります。 (XXX - 遅延アプリってSYN/ACKのことだと思う…）

## Keep Alive

だからもういろんな工夫をしなければ。HTPP1.0/1.1ってのにはそもそもKeep Alive（キープアライブ）っていう機能があります。これは何かっていうと、一度接続したときで、1.0だったら"Connection: Keepalive"っていうヘッダをいったん送って、appサーバーからコネクションキープアライブが本当は返ってきて、それに1.0の場合はコンテンツの中、そうですね、というのが返って、どこでそのコンテンツが終了するのか、このコンテンツの終了までが読み終わったら、次のリクエストを送っていいというふうな状態にしたうえで、接続がうまく、どこかで、どこのコンテンツが送っても確認していこうと。HTTP 1.1の場合はTransfer EncodingにChunked Transferっていうのがサポートされていて、デフォルトでキープアライブを送ります。

## C10K problem

ただ、これ使えばいいかっていう話なんですけど、ただここにも問題があって、いわゆるC10K（シーテンケー）問題ですね。コネクションを大量に張ったときにどう動くかという問題です。

昨日発表中にいたんですけど、Apacheを使っているという、Apacheを使っているのはもう古い人とか言ってるんですけど、〓nginxのわり方〓もデフォルトでもうC10K、コネクションいっぱい張っても大丈夫なような設定になってると。そのコネクションいっぱい張ってる状態から、appサーバーに向かってキープアライブのリクエストを大量に張ると、appサーバーは当然詰まります。

なぜかというと、Preforkモデルで1コネクションにつき1プロセスが占有されるという問題があるのです。

Starmanの場合はデフォルトで5プロセス、Starletだと10プロセス上がるんですけど、これ一致しないとこれで5つのコネクションでいっぱいになるし、Starletも5つのコネクションでいっぱいになると。例えば100個とか200個くらいまでだったら直接上げることはできますけど、1,000個2,000個というプロセスを上げると、それはもうボトルネックになる。負荷の原因になってしまうというのがあります。

Monocerosっていうのは、プリフォーキングのモデルなんですけど、コネクションをいっぱい張れるという面白い特徴を持っています。

どういった仕組みなのかっていうと、まずクライアントが普通にワーカープロセスに、〓〓されたワーカープロセスに向かってリクエストを送った、処理してレスポンスを返したあとに、これをマネージャーのプロセスに返します。後ろでUNIXドメインの通信をずっとマネージャーを通して〓ストラッカ〓プロセスがしていて、マネージャーを通してそこで監視します。ここで〓ケントトウループ〓で監視していて、クライアントから次のリクエスト、キープアライブの次のリクエストが来たらこのソケットを〓こいつの〓空いてるバッファに渡す。そこでリクエストを処理してレスポンスを返す、こういう仕組みになっているんで、コネクションによってプロセスが占有されることがないっていう構造になっています。

このワーカーなんですけど、このままユースケーススタディとしてあって、これ〓そのまま張る〓一般には使えないんですね。ただ、イベントドリブンでできているこのマネージャープロセスっていうのが、エニ−イベントでできているので、〓それ作れば〓それ以降、そういった仕組みになっています。

ベンチマークなんですけど、通常のAPの例えばバッチベンチなとこっていうのは、接続を張ればコネクションを使って大量のリクエストを送るっていうふうなベンチマークになっていて、通常のたくさんのブラウザがある状態から大量のリクエストが来るっていう状況を再現できないんですね。

それを再現するときにちょっと別のプログラムを作って、接続をして何かのリクエストを送って、そのリクエストがキープアライブがタイムアウトで切れるまで放置するっていうベンチマークをすると、左側がStarletでMonocerosが右側で、トータルタイムが54秒と8なんで〓6秒と5倍〓くらい速いんで、しかもリクエストの失敗もない。タイムアウトしてしまいません。大量のリクエストを送ってるけどプロセスがその〓スリット〓を受け取ってくれないからタイムアウトして失敗すると。そういうことがMonocerosではないっていう特徴を持ちました。

Monocerosなんですけど、結構頻繁にバージョンを〓僕が〓上げているんですけど、だいたい安定しているんじゃないかなあとは思ってます。なので、プロダクションでぜひ使ってみてください。

（Plack/PSGI Basic）

今まで散々PlackだとかPSGIっていうのを言ってたんですけど、そもそもそれって何だっけってのをこれから話します。

結構、口酸っぱく言われてると思うんですけど、PSGIというのは仕様です。PlackっていうのはそのPSGIの仕様をインプリメント、実装したものです。PSGIって何かっていうと、アプリケーションをサブルーチンで表現して、env（エンブ）というふうなものを受け取ってレスポンスを返すと、こういったものになってます。

envなんですけど、何が入っているかっていうと、CGIの時代からやってた方っていうのはよくご存知のこの、ちいちゃい、いわゆるkey。ハッシュのkeyですね。リクエストだとかHTTPなんとかっていうヘッダーの情報が入ってきてます。それに加えて、PSGIが使う〓バイセン〓だとか、インプットとか、エラーの、〓スタットっていうのはスタットのときのいうのがよくあるいれると〓、それが入ってます。

レスポンスというのがどういう形があるのかっていうと、まず一番オーソドックスな形なのがこれで。大きく分けて3つですね。一番最初がステータスコード、HTTPの、200〓オッケーの200〓ですね。2番目というのがヘッダー、これが配列のリファレンスですね。これは大事な。最後、配列の中に文字、コンテンツを入れるという形になってます。

あとはちょっと別な形として、こういって、IOハンドラですね。IO〓へフリ〓、IOタイプだとかっていうものを、オブジェクトを渡すこともできます。

こっからは結構難しくなってくるので簡単に流すんですけど、レスポンスをいきなり返すんじゃなくてサブルーチンだけを返しておいて、その中で遅延させてレスポンスを返してやるとか、先にヘッダー文字だけ送ってレスポンスをさらに各処理に返していくっていうこともできるようになっています。PSGIの仕様の中ではサポートされてます。

PSGIのサーバー、何をするものなのかっていうことなんですけど。簡単に言えばenvを作って、アプリケーションを実行して、返ってきたレスポンスをもらって、それをプロトコルに合わせた形で出力するというものですね。

簡単に凝縮するとこんな感じですね。

Apacheだったら〓CJケーリング〓だったり〓ボットパー〓だったり、〓エンジンX〓で〓CJ、パースCJ〓を使ってアクセスしてきて。いろんなプロトコルでアクセスしてくるんですけど、最終的にはenvを作ってアプリケーションを実行して、ソフトをもらって、そのレスポンスの配列をプロトコルに合わせた形で整形して返してあげる。これがPSGIのサーバーの役割です。

PSGIサーバーなんですけど、また別の名前で、Plackハンドラっていうことで呼ばれたりもします。Plackサーバー、Plackハンドラって呼ばれたりもします。

何か違うかっていうと、PlackハンドラっていうのはPSGIサーバーとPlackとのインターフェイスです。簡単に言うと、PSGIサーバーをplackupで実行するための〓ADI〓です。

スターマンStarman::Server（スターマン・サーバー）っていうモジュールが実際PSGIサーバーの実装。Plack::Handler::Starman（プラック・ハンドラ・スターマン）っていうのが、Plackハンドラ。こういうふうな関係になってます。なのでStarletでMonocerosのソースコードを〓切る〓ときもだいたいこの形式になっていて、Starletサーバーがあって、Monocerosサーバーがあって、Plackハンドラがその2つとの間。こういう関係になってます。

（Make PSGI/Plack Server）

ここから、PSGIの仕様がだいたいわかったところで、PSGIのサーバーを実際ちょっと作ってみようという話になります。スタンドアロンで動く簡単なWebサーバーを作るとだいたいこんな感じです。細かく読まなくてもいいんですけど、60行ぐらいでだいたい動くハンドラができます。

（Listen and Accept）

ちょっとずつ見ていくと、リッスン（Listen）指定。そのソケットを受け取るところですね。IOソケットを使って5000番をリッスンして、何か新しいことが出たらヘッドをコネクト。この前のアクセプト（accept）っていうところで、ソケットの新しいソケットが来るのを新しい通信が来るまでブロックしてくれるので、こうやってホワイル（while）で回しておくと動くってことです。

（Read a request）

次の、リクエストを読むところっていうのがこんな感じです。ごにょごにょとenvを作るところだけ要するんですよ。envを作って、最後のところ、一番最後の行ですね。〓パーセイHTTPリクエスト〓、これが、〓Plack HTTPパーソン〓っていうところから提供されるものなんですけど、HTTPのヘッダーを〓ファンスファンス〓して、envのところに適当に打ち込んでくれる、そういうモジュールになってます。これがあるだけで、すごい、うちでWebサーバー書くことがすごい簡単になってます。

（Run App）

その次、envができたんでアプリケーションを実行するところなんですけど、上のが一番簡単にプリミティブに書いた棒打ちをする感じですね。下にはPlack〓カル〓辺りから提供されてる機能ですが、下の場合だとapp（アップ）を実行するところの〓トウロ〓に〓イワロ〓をかけて、さらにその中にはエラーになる、エラーのレスポンスを作ってくれるところで入れてます。なので下を使ったほうがシンプルになります。

（Write a response）

最後、レスポンスを返すところですね。これも結構長いんですけど、やってることっていうのはヘッダーの配列をくるくる回して、レスポンスヘッダーを作っていって、最後に〓ジスライト〓でそれを書き出す。ホイールのところの配列なんですけど、ぐるぐるジスライトで回して最後に通す。

これで一応できて、サーバーのこと、さっきのコードなんかも実行することができるんですけど、たぶん遅いです。問題っていうのはいくつか。

（This PSGI Server has some problem）

問題あるのは、大きく分けると3つで、一番に受けれるっていうか、さっきのプロセス1つなんて、1つしか通信リクエストは受けることができない。あとタイムアウトがないんで、タイムアウト、Telnetでアクセスして放置しておくとほかのリクエストを一切受け取ることができないですね。あと、あんまり速くないっていうことがあります。

なのでこれをチューニングしていきましょうっていう話です。

（Increase concurrency）

まず、コンクレンシーですね。大量のアクセス、いくつかのアクセスを書いて出れるようにしようと。

（Multi Process IO Multiplexing or Both）

方法はいくつかあるんですけど、マルチプロセスにする。プロセスをいくつか立ち上げて、それらがリクエストを受ける形にする。または1つのプロセスなんですけど、IO多重化によって1つのプロセスの中でいくつも通信を受けることができるようにする。もしくは両方やる方法があります。

（Preforking model）

ここで採用するのはプリフォーキングで、IO多重化は結構面倒くさいし使い道も限られるので、こっちのほうがいい。シンプルにできる。スケーリングします。

プロセス、プリフォークの。さっきのMonocerosのやつもすごい似ているんですけど、簡単に説明すると、まず〓デレクター〓でマネージャーの親プロセスでバインドしてリストにするところまでいきます。そのあと子プロセスを〓コウキ〓していってその中で〓セイトウ〓のところで止まっていくと。これがある。こういった動きをするのがプリフォーキングのモデルです。で、クライアントはそれぞれのところに通信をしていくっていうもの。

このプリフォーキングを使うにはどうしたらいいかというと、〓バリヤク〓をどう動かそうとするのかが重要なんです。これを使うのが一番簡単です。これ〓プリフォーク〓で、この場合〓マックスオータ〓のところで5つバックアッププロセスを起動して、〓キュー〓とかされたときに〓とまりえる〓感じでシグナルレシーブなんですけど、〓コステ〓の中で、その動きの中でスタートというところで、このスタートのところで子プロセスを起動していくと。その中では役割の配分が入ってくる。まあこれだけで、その子プロセス起動するのに5つまでコネクションができるようになります。

（NO Accept Serialization）

次の話題なんですけど、一番最後のアクセプトのところですね。アクセプトのシリアライゼーションという話題があります。これは何かというと、クライアントが接続しに来たときに一斉に子プロセスを、ワーカーの子プロセスを起こしてしまうっていう、こういう問題があります。自分が接続を受け取るんだということで、それぞれのプロセスが起動してしまう問題ですね。最終的に起動するんですけど、実際受け取るのは1つです。

（Thundering Herd is an old story）

あとはこのサンダリング・ハードっていうんですけど、この問題というのは完全に過去の問題ですね。〓ターンOS〓っていうか、〓カレの2.4〓の時代からなんですけど、OSが普通に1つしか起動しないようになってます。なのでサンダリング・ハードっていうのは起こりえないってのが最近のは入ってます。

なので、アクセプト・シリアライゼーションってのは要らないよねっていうのが今の流れですね。ただ、Starmanなんかもそうなんですけど、いくつかのインターフェイスを同時に配分できるんですね。そういったときには何かしら別の方法で、どのインターフェイスについて何をするか、アクセプトするかっていうあたりでシリアライゼーションが必要になることもあります。Monocerosは実はしてないんですけども。

（TCP_DEFER_ACCEPT）

次はTCPデファーアクセプト。これの解説をします。これは何かっていうと、さっきの〓ドレセツ〓はコケル瞬間のところですね。通常〓ハイフェイ〓のところに行けば接続のところだけエスタブリッシュな状態。接続を完了してTCPのハンドシェイクが終わった段階でアクセプトが起きるんですけど、そうではなくてデータが到着した。HTTPの〓イワレ〓で〓トアントワン〓と到着した段階で初めてアクセプトを起動するっていうことができます。

これが何かっていうと、デフォルトの状態でクライアントAとBがあって、クライアントAがまずエスタブリッシュの状態になったところでアクセプトを起動します。で、実はクライアントAっていうのがずーっと、接続したはいいけど〓ベスト〓をなかなか送ってこないというので、ずーっと下側でブロック、〓ティーヨン〓の状態でブロックしてしまう。で、ようやくここ一番下で〓リクエスト〓が来たんでアプリケーションを実行してレスポンスを返す。で、次のクライアントBについてはそのあとに回されてしまうんですね。

デファーアクセプトが入っているとどうなるかっていうと、アクセプトが、データが来ないとアクセプトが起動しないんで、ここが〓回路状〓になって、クライアントBから、実際に〓デッカ〓のリクエストが来たクライアントBから実行して、クライアントAがそのあとに実行されると。なので、〓アイドルタイム〓がある分だけ効率よくリクエストをさばくことができると。もちろんこのクライアントを〓エードロ〓してあげて、こっちの〓キャラクセル〓も処理することはできます。

で、この、デファーアクセプトなんですけど、これStarletのコードから持って来たんですけど、実はLinuxしかサポートしてません。FreeBSDでは若干もうちょっと、HTTPのリクエストが完了されている。そしたらアクセプトはできないわけですけど、まあLinux、それとちょっとだけ違う例を書いたんですけど、Linuxの場合だけでこうやった例で。で、こっち9ですね。これ定数なんですけどStarletのコードこうなってるんですけど。たぶんまだ〓パード〓のソケットの〓ダイ〓のモジュールの中からそれをエクスポートする機能がないのかなあという感じです。

（timeout to read header）
:
次、先ほども言った、タイムアウトする機能の実装ですね。

（alarm）

方法いくつかあるんですけど、まず1つ目がアラームです。タイムアウトといったとき一番簡単なのがこの方法だと思います。で、実際キーワードの〓ボルク〓の中でシグナルのアラームをセットして、アラームでタイムアウトの秒数を指定して引用すると。それが中でもしタイムアウトになってしまったらタイムアウトの定数が入ってくるんで、それに加えてネクストで次のほうに〓ショウナン〓する。そうですね。あったら、そのリクエストを処理する。次の段階に入っていきます。

（nonblocking + select）

もう1つの方法がノンブロッキングにする、あとセレクトを使ってそれを待つ。

これもまたStarletのコードなんですけど。Starletのコードじゃないや。まあStarletのコードを簡略化したものなんですけど、アクセプトしたコネクションでのブロッキング「0」でノンブロッキングの状態にします。これによってリードかけたりライトをかけたりするときに、それらができないときに、普通ブロッキングだとリードをかけて実際データが来てないとずーっとそのリードのところで止まってしまうんですけど、ノンブロッキングになってるとリードをかけてデータが来てなければすぐに〓パート〓のほうに行ってまだデータが来てないという状態に戻せるようになります。それを使うんですけど。

これをまず、〓ダイドウ〓セレクトを使ってリードができるようになるまで待つよっていうので、これリードタイムアウトっていうのを使ってます。で、指定したリードタイムアウトの秒数の中で〓テイク〓が実際データが来れば〓レジ〓の中に入ってくるんですけど、そうじゃなくて空っぽだったらというので次に行きます。もし空っぽだったら次の文字までデータを読んでリクエストを処理する流れになります。

（alarm vs. nonblocking + select）

アラームとノンブロッキング・セレクト、〓いったんは増えます〓。Starmanは〓上〓です。Starletは下なんですけど、どちらがいいかということなんですけど、ひとつの〓基準〓としてシステムコールが少ないほうがいいと思います。

（Fewer syscalls is good）

システムコールって何かというと、普通のWebアプリケーション、ユーザーの、ユーザーのコードからハードウェアに対して直接命令を送ったりするのは難しい。なかなかできないようになっているのが普通のOSです。その代わりシステムコール、OSに対して命令を送ってそれらが〓上に〓来るようにしながら、通信をしたり、ファイルの操作をしたりします。そんなシステムコールがすごいたくさんあるんですけど、今まで例に出てきた中ではリッスンだとか、オーボーだとか、リード、ライト、セレクト、全部システムコールです。

（alarm）

アラームの場合どういうふうなことになるかというと、実際9回も、1回のリードをする間だけで9回もシステムコールが発行されます。ローカルシグアラームなんですけど、その部分が一番上ですね。なんかシグナルっぽい操作で、シグの中でシグナルなんかを指定してやります。さらに4行目も〓ツメマル〓なんで、実際に●が走ってると。で、ローカルシグナルなんで、そのブロックが終わると、それは削除されますね。その削除の作業というのがリードの下の3つです。デフォルト状態に戻して最後にやってる。これが9回になります。

（nonblocking + select）

ノンブロッキングとセレクトする場合ってのは実際、4回ですね。

一番上の〓ホントに必要になるの2万語なんですけど〓、ノンブロッキングを〓エフコントロール〓に対して、ノンブロッキングを指定してセレクトしてという。たったこれだけになります。

なので、たぶんこっち側のほうが動かす効率がいいっていうのは言えます。

（Parse a request with “C”）

次の話題なんですけど、リクエストを、HTTPのリクエストをCで回すという話です。

これは一番簡単で、HTTPパーサーXS、これも〓カズノ〓さんのモジュールなんですけど、これを入れるとPlack HTTPサーバー、それを使っているので〓効率が良くなります〓。

（TCP_NODELAY）

次、リクエストを処理してレスポンスを返す部分ですね。その話なんですけど、TCPノーディレイというふうに書いてます。

TCPっていうのは、なんのか〓WIOD〓っていいますかね、これがデフォルトで動いていて、速度には影響っていうのはない。ライト、〓スクリプタ〓に対してライトを送ってもすぐにそれを獲得して飛んで行かないようになってます。

図にするとこんな感じですね。ライト・フー、バーってしてもそれがしばらくの間、200ミリセックなんですけど、ファイリングされて1つの塊りとしてインターフェイスのほうに送られます。なのでこのファイリングする分だけ〓コウジョウトップ〓が遅延してしまうんですね。〓効率〓対応などでも、1つの物体にまとまるので効率は良くなるけど遅延してしまうと。

TCPノーディレイを指定すると、ライトとライト同士に〓カケフードかけるとこ〓に飛んで行って、〓ライトパーシューの前にパーミット〓に飛んでいくと。こういうふうになってます。ただこれを多用しすぎるとTCPのパケットのカスがすごいことになってしまって、逆にそれも効率が悪くなる原因になる。

どうするかっていうと、一番簡単なのは、アプリケーションの中でまずコンテンツをジョインしてひとつの塊にして1回で送る、そのほうが確実です。

（Write in once join content Server）

とりあえずそれとなく、書いてますけど、重要なのは一番下で、ヘッダーのラインとボリュームコンテンツを全部分類して、1回の〓シスライト〓で書き出している。こうすることによって1回のパケットの中で全部が書き出されるんで、〓こっからこうして〓、さらにTCPノーディレイも効いてるんで、遅延なくリクエストの状態がストアできる。こういうふうな工夫が入っています。

（accept4, writev）

この〓サンネンツキ〓ではちょっと詳しくは述べないんですけど、accept4（アクセプトフォー）っていうのが、先ほどのTCPノーコードっていうんですかね。あれをアクセプトしてコントロール、〓シンルイ〓のノンブロッキングを指定するんですけど、それを全部アクセプトの中で指示を1回で済ませるのがaccept4です。

writev（ライトブイ）っていうのになると、〓デッカラタイオー〓っていうモジュールとか、〓ナイオウベクター〓とかっていうモジュールでサポートされてるんですけど、配列をそのまま渡すことができるんですね。なので、レスポンスの配列をそのまま渡すとそれを全部、whileで回すことなく1回のシステムコールの中で送り出すことができるものがあります。

ただ、あんまりまだサポートされてないですね。accept4については確かCPANモジュールの中でもまだないです。こういうことでパフォーマンスがたぶん上がる。一番〓ココタキ〓たいんですけど、上がるサーバーを期したいと思います。

（Choose PSGI/Plack Server）

ここから最後のほうになりますけど。実際にCPANに上がっているサーバーの選び方ですね。これをちょっと〓インブン〓的に話します。CPAN、いっぱい結構あります。Plackハンドラナントカっていうので検索すると、おそらくゴマンといっぱい出てきます。その中でたぶん普通に使うだろうなっていうのをいくつか紹介していきます。

（スタンドアロン）

まずスタンドアロンですね。PlackハンドラースタンドアロンまたはPlackハンドラHTTPサーバーPSGIかな。長いですね。

これは何かというと、plackupしたときに〓カイマイスウ〓でサーバーを指定しなければ自動的に起動するモジュールです。先ほど一番最初にさっき作った、一番最初の状態にほぼ近い、シングルプロセスで起動するサーバーです。このへんをサンプルで使うことが多いと思います。

（Starman）

次、Starmanですけど、プリフォーク型のWebサーバーです。HTTP1.1、HTTPSもサポートしています。ほかのGSGIサーバーにはない特徴として、マルチプルインターフェイスですね。この辺に対応しています。いくつかの、このポートとこのポートとこのポートとをunixドメインのサーバーを同時にリッスンすることができます。あとサーバースターターを利用したホットデプロイもサポートされています。

（Starlet）

Starletなんですけど、これブログでも使っているサーバーなんですけど、プリフォーキングのサーバーで、HTTP1.1に最新のモジュールで対応しました。作者は〓カズノ〓さんですよね。サーバースターターを利用してホットデプロイができます。

どこが一番いいのか結構話題になるんですけど、Starmanっていうのはネットサーバーっていうモジュールをベースに使ったものです。ネットサーバーっていうのは結構難しいモジュールで、何か調べようと思ったとき結構難解なんですけど、Starletっていうのはほとんど〓テライチ〓でできてます。シンプルにできてて、しかも先ほどのチューニング、僕が話してきたチューニングってのは全部入ってるんで、かなり高速に動きます。

（Monoceros）

次なんですけどMonoceros、先ほどお話ししたんですけど、HTTP1.1をサポートしています。Starletをベースにしてるのでやはり先ほどのチューニングっていうのは全部入ってて、高速に動きます。

（Twiggy）

ちょっと毛色が違うTwiggy（ツイッギー）っていうPSGIサーバー。これエニーイベントでできてて、ノンブロッキングとストリーミング、非同期処理ができるようになってます。Twiggy自体はシングルプロセスで動きます。なのでマルチコールをきかせることができない。マルチコールを使わなくても、プロセスの中でいろいろ通信をして、チャットを作ったりだとかという中ではこれを使うしかないですね。

（Twiggy::Prefork）

Twiggyをマルチプロセスに対応させたのがTwiggy::PreforkというPSGIサーバーです。これは何かっていうとTwiggyのアクセプトをする前に〓プライオリで〓プリフォークを使って子プロセスを起動するっていうことができるようになってますね。ノンブロッキングもストリーミングもサポートしながらマルチプロセスができます。先ほどの大量のアクセスに、1個以上の接続に対してどうやって対応するかっていうことを両方やっているモジュールになります。

（Feersum）

次はちょっと毛色が違うFeersum（フィールサム）サーバーなんですけど、EV/libev（イーブイ・リブブイ）っていうのは、イベント処理のEポートだとかっていうのを隠蔽するモジュールに類するライブラリで、それをベースにして作られているPSGIサーバーです。たぶんですけど、ベンチマークそんなに詳しく打ってないですけど、たぶん一番速いと思うんですこれが。いくつかあるサーバーの中では一番速く〓ネーク〓動きます。もちろんEVとかlibev使っているので動きがそういう意味で非常に〓処理タイム〓です。知らなかったんですけど、調べてみたらマルチプロセスもできます。いくつか〓ノード〓を起動することもできます。ただ試したことはないんでなんすけど。あと〓イスポン〓、われわれのイスポンという●なんですけど、これを〓ジムエイシャのイチ〓がこれを使いました。

（How to Choose PSGI Server）

いくつかサーバーを紹介してきたんですけど、これらどうやって選ぶかというのが次の話です。

簡単に図にまとめるとこんな感じですね。1行目がCPUを使う処理、テンプレートだとかSQLだとか〓キャッシュ〓だとかっていう、わりとCPUを使う処理っていうのをする場合は上です。イベントドリブンする起動〓キャリア〓が必要なものは下になります。

シングルプロセスとマルチプロセスっていう違いがあって、1つのプロセスの中に全部を入れなくちゃいけない場合は左側で、いくつかあるプロセスの中で〓ネットのイコート〓ってのは右側ですね。あとプリフォーク型についてはもちろんシングルプロセスでやる意味はないので全部右側になります。こんな感じで選んでもらったらいいかなって思うんですけど、基本的には右上か左下かのどっちかなのかなってのは思います。

（Finding Bottlenecks of Performance）

これが最後の話題です。今PSGIサーバーいろいろあって、それがまああるんですけど、そのボトルネックですね。どうやって使うか。チューニングするときにボトルネックをどうやって見つけるかなんですけど。

（use Devel::NYTProf）

1つ目がデベルNYTプロフを使うっていう方法です。最近のバージョンでフレームグラフっていうのをサポートしてる。これがすごい素晴らしいんですけど。これ、Starmanを起動して、〓出力ログ〓とかもいろいろ入っている状態で、あまり〓キョウリトウェイト〓を掛けた状態なんですけど。この上の段との差が大きいところっていうのは何かしらの処理をして時間が掛かっているので。で、そこを探してチューニングをしていくことになります。

（Flame Graph is awesome）

〓デモプラン〓でいくつかプロセスが上がってるんで、それをどのプロセスIDなのかってまず見つけて、ntyprof.out.{PID}っていうのが、今たぶん〓出力したもの〓の中に入れておいたら対応できるので、それをnytprofhtmlで解析して見ます。アウトをかけてもファイルを見ても、親プロセスの情報しか入ってきてないので、実際リクエストを受けてないなんて〓例みたいなシーン〓になります。

（use strace or dtruss trace syscalls）

もうひとつっていうのが、strace（sトレース）とdtruss（dトラス）っていうコマンドですね。dtrussっていうのがコールサインになっています。これは何をするかというと、システムコールですね、これをトレースするわけです。

使い方はこんな感じですね。よく使うオプションがこんな感じなんですけど、「-tt」っていうのが時間〓係数〓で、「-s 200」ってのが200バイト〓書き出す〓、「-p」でpidを指定してそれを。

ただstraceってのも、これもエラーとともに全部返ってしまうので、〓配布リリース〓とかって見ることができないんですね。こんなで、表示エラーを表示してるのを配布して、さらにファイルに書いてあとで〓よーく〓見てたりします。

出力するとこんな感じです。僕すごいこれ見慣れててだいたい分かるんですけど。アクセプトしたあとに、なんかIOコントロールだとかLCだとかあの辺なんかすごい無駄っぽいなみたいなことが、僕は分かるんですけどどうなんでしょうね。

だいたいなんか、キャプチャした中に〓データイチビー〓だとか、ライトで〓イチビ1年200億円〓とか書いてると、だいたいその辺から探すといいなと思います。

（in conclusion）

はい、まとめでーす。PSGIサーバーはとても速くなりました。最初にベンチマークの値で見たとおり、半年前に比べてだいたい2倍くらいの速度になってます。案件にもよるんですけど、Starletで最大15万リクエスト／セックまで出せることは可能で確認してます。なのでPSGI/Plackとても速いし安定してます。すばらしいですね。

その中でもいくつか問題があったりとかした場合は、RT、Git Hub Issue、Pull Reqs、あるいはIRCだとか、あと〓ハッシンダン〓とか●とか、僕のほうまで何かメッセージで送ってもらうと何か〓問題〓探したりするかもしれません。ザッツ終わりでーす。ありがとうございました。

