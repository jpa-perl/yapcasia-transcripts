# フルテストも50msで終わらせたい 〜 FreakOutの取り組み 〜 

2日間お疲れ様でした。前夜祭から言うと3日ですか。ずっと人の話を聞くというのは結構疲れると思うので、簡単に進めたいなと思います。

僕のトークタイトルなんですけど、「フルテストも50msで終わらせたい」というタイトルで、Perlのmake testっていうのが、●しないと動くわけですか〓みたいな、そういう話をしたいと思います。

僕、自己紹介なんですけど、久森達郎（ヒサモリ・タツロウ）って言います。だいたいmyfinderっていうIDでtwitterなどしています。FreakOutという会社に勤めてまして、今はインフラのチームに入っていてサーバーの面倒をみたりとか、あとはグラフとにらめっこしたり、そういった仕事がメインです。

![](http://30d.jp/img/yapcasia/6/700_large.jpg "(c) Japan Perl Association")

去年は嬉しいことにフリークアウトのシステムをご紹介して、Best Talk Awards 3を頂きまして、非常にこうありがたく思っております。

（50ms or die）

こういう感じですね。

で、最初になんですけど、すいません、さすがに50msではメインテストは終わりません。それは無理です。はい。

で、今日話すとこなんですけど、Perlアプリケーションの基本的なところ。それからFreakOutのテスト環境とCIというのはどうやってきたかとか。どういう推移でここ1、2年やってきたかみたいなお話をして、それから増えたテストっていうのをどうやって高速化していくみたいな話になります。

（今回話さないこと）

　今日は、画面系のテストに関しては話しません。昨日午前中に同僚のモリヤマさんがBrowserStackを使ったテストについて話をしてくれました。この資料はもう確か上がっているはずなので適当に探してください。

Real Time Biddingそのもの、FreakOutのシステム自体の話では、もう昨年のトークの資料で、WEB+DB PRESSに書いた記事ってのがあるので、そちらを参照してください。ボリューム70なんで今本屋にはないですけど、総集編が今本屋にあります。

（Web-DB press総集編Vol.1〜72の表紙）

こういう表紙です。はい。なので皆さんお買い求めください。

あと、テストモジュールに関して踏み込んだ使い方みたいなところっていうのは、昨日すごい、soh335さんの話とだだかぶりしていたので、スキップして行こうかなと思います。なので最初に話したPerlのテストおさらいをさらっと流す感じで話していきます。

（Perlのテストのおさらい）

で、最初にPerlのテストなんですけど、わりとちゃんとPerlのテストを書いてるぜっていう、おれのプロダクトたちは書いているぜみたいな。（客に手を挙げさせる）素晴らしい。まあみんな書いてる。いるっていっても10％ですね。
　ということで、いろいろと基本的なモジュールに関して話していこうと思ってたんですけど、この辺は（スライドを流していく）、Test::More、Test::MockTime、Plack::Test、Test::mysqld、だいたいこれくらい使えば基本的なテスト用途は満たせていい感じですっていう話で。ここはまるかぶりしていたので、soh335さんのスライドの資料にお任せをします。
　で、FreakOutのテスト環境とCIの話なんですけど、基本的にアプリケーションはPlack::Testでだいたいカタがつくケースが多くて、画面系以外のところに関してはほとんどHTTPの通信とかで、画面とか伴わないので、基本的にリクエスト/レスポンスに落としやすい、というところで。
　ちょっと潰れちゃってますね。Plack::TestのSYNOPSISに書いてあるようなものをそのまま書いただけです。これでリクエストとアプリケーションを作って、そのテストの中でそれを使ってリクエストを実行してテストする、そんな感じです。
（CLI（バッチ）処理）
　CLIとかどうしてるかっていうと、単独のモジュールで開発した後、CLIラッパーみたいなモジュール、フレームワークが社内にあるので、それを使ってラップして呼びだしているということなんで、基本的にはCLIっていうのを意識してモジュール書くというよりは、処理を書いてそれをCLIでラップしてというような作りしています。
（ログ処理）
　ログ処理なんですけど、基本的にはダミーのログを特定のディレクトリに置いて、そこでそれを対象に集計処理とかをかけて、処理後はクリーンアップするみたいな。まあ一般的に皆さんよくやるような処理をやっています。
　で、これはsoh335さんも話してたんですけど、うちもt::Utilsというのに入っていて、ここでテストを捗らせるために、接続先DBをテスト用に置き換えたり、テストごとにミドルウェア起動してポートアイテムを〓サンショウ〓番号対応というのは全部、こういうt::Utilsの下にこういうモジュールを作って、それをuseすることで処理して、毎回テストでは書かないようにする、みたいなことをやっています。

　なので、Perl以外のミドルウェア、mysql、memcached、あと●TPを使っていますけど、それ以外にRiakとか入れ始めたので、Riakの起動停止もこのへんでフォローするというようなことをやってます。
（リスト）
　こんな感じですね。config fileを最初に上書きして、そのあと下の、別途メソッドにしているんですけど、test memdとか、test●とか、test dbとか、そういう感じですね。これでinitializeしている、そんな流れです。
（ヘルパモジュール）
　もう1個、ヘルパモジュールというのを書いていて、別途、手元でmake testを走らせたいときとかに、Test::Prettyに差し替えたいような要求を吸収するために作られてます。で、runtests、あとは、runtestsのテスト一覧を渡す前にシャッフルするみたいなことをやってます。
（MakeFile.PL）
　MakeFile.PLと書かれています。あー潰れちゃってます。見えます？ スライドあげるので見て下さい。MakeFileの中に〓テストビアカンデンス〓という、自分のモジュールに置き換えてそれを処理してもらうという感じの書き方をしていて、その実際のMakeHelperの中でこんな感じで、Harness classに置き換えて、引数にprettyが当たっていればTest::Prettyを使って、ということでもって、そんなことができます。
　テストをシャッフルするっていうのもやってて、これは単純にFile::Findで持ってきて、最後シャッフルをかけてruntestsに渡すみたいなことをやっていて。
　これは結構、もしやってない人がいたらやったほうがいいなと思っている策で、結構知らない間に順序に依存するテストを書いてしまうことってあると思うんですよ。あと、自分が書いたテストの結果に依存したテストをほかの人が書いちゃうのがあって。最後のはいいです。
　具体的にはDBのクリーンアップ漏れが発生して、本当は消えてないといけないレコードが入っていることを期待するテストを書いちゃうとか。あとは、ほかの人がクリーンアップするように直したほかのテストをfailしちゃうみたいなケースとかは、たいへん気づけない。
　あと、同じファイルを違うテストから参照するケースとかも、このへん、本当は〓ファイルネーム〓とかを使ってそのテストで閉じたものをやるべきなんですけど、そうなってない場合とかというのは、〓ハンコウ〓する可能性があります。そんな感じなので、これはわりとサクッとできるので、もしやられてない方がいたらやったほうがいいかなと思ってます。
（Ukigumoとのつきあい）
　次、Ukigumoとのつきあいですけれども。特にUkigumoサーバー、手は入れてません。そのまま立ち上げているだけです。Ukigumoクライアントは使ってなくて、独自にクライアントを実装してます。
　FOutTesterという名前で社内で作っていて、CIを開始するための枠組みで、テストに未実効のブランチがあるかないかをバッチで毎分kickしてして探してきて、実行します。で、SQLiteに実行したブランチ名とリビジョンを記録しておいて、2回同じテスト走らないようにしている、という感じ。
　で、テスト結果をUkigumoサーバー以外にポストするという処理をそこに書いていて、今はせいぜいメールぐらいですけれども、IRCを使っている場合はそこでIRCを〓確認〓してもいいのかなと思います。
（画面を変えている）
　こんな感じでテスターのbase classを作っていて、その中で、実体はこのrunの中か、このgithubのリポジトリを取ってきて、指定のプロジェクトをrunして、結果までparseされてUkigumoに投げるみたいな。Ukigumoに投げる処理は普通に、LWPに任せるみたいな話の処理ですね。というのがわかる。
00：10：10
　これを継承したそれぞれのプロジェクトいうのもあったりします。ファイルが〓いうよっか〓。
（ここまでのまとめ）
　という感じで、基本的なテストで、FreakOutのテストとUkigumoちゃんとの付き合いというのを話して、ここまで説明をしました。
　実施済みのブランチを記録して2回実行させないとか、テストを実行するにあたってヘルパモジュールをこさえて捗らせるということをやってます。
　という感じで、いったんここまでで小休止したいんですけど。ご質問等あれば。手を挙げていただいて。その隙に水飲ましてください。特にございません？ 大丈夫そうでね。
　じゃあ次。ようやく本題の増えたテストの実行の高速化っていう話になるんですけど。その前に、FreakOutのテスト、ここまで形を作りましたけど、ここに行くまで結構いろいろ1年の間にありまして。1、2年の間、こんな感じで遷移しました。
　去年のYAPC前までは3〜4人で開発してまして、あんまりちゃんとCIとか整備してなくて、手元のVMで実行して良ければチェックしてマージしてリリースということをやってたんですね。
　すぐに結構多人数になってきまして、ここでCI入れようねっていうことで。メンバーみんなでCI環境を急速に整備していって、ここまでで話したような技法とかいうものを作りました。
　で、今年に入ってからさらに倍ぐらいの人数に増えていて、ブランチとか数増えてきてプッシュされるとテスト走るようになっているんで、同時に実行したいテストはCI実行順番待ち避けるようになって、単体でも時間がかかるので順番待ちしているととても時間がかかるというような状況になっちゃってました。
　で、現状なんですけど、.t file（ドット･ティー･ファイル）だけでも800以上、直近で〓シーラされた〓なんと、僕が見たメールで830いくつとか、そのぐらいです。いうようなテストファイルがあって、これ、メイクテストを愚直に打つと2000秒ぐらい返って来ない。3、40分返って来ないかな。っていう感じで。結構つらいねという感じでした。
　そもそも時間掛かりすぎですよと。ブランチがいくつもあると結果がわかるまでにすごい待たされちゃう。例えば5個開発ブランチがあって、活発にプッシュされていると30分かけて結構な。すごいですね。3時間ぐらい待たされるのか。プッシュしたらもうその日は結果が分かるまでリリースできないけど、結果が分かるの8時過ぎちゃうからDeployできないからまた明日になるとか、そういうすごい開発速度が遅くなっちゃうみたいな事態が起こったりするという状況になって来ました
　で、そんな感じでですね。待たされた末にfailしていると切なくてちょっとやる気がなくなっちゃいますね。そうなってくると、事故るリスクが高まってくるっていうのはどうしてかというと、テスト遅いし、CI通すと遅いからもう手元でとりあえずテスト通して、オッケーならマージして出しちゃえみたいなことをやるっていう人が出てきたりする。そして誰もフルテストをしなくなっていくみたいな話になると、せっかくここまでサイクルを作ったのに全然使われなくなっちゃう。形骸化してっちゃう。そうなると意味がないんですけどね。
　これ同僚の人のツィートなんですけど、なんか関係ないと思っててもテストが落ちたというケースが出てくる。これはフルテストを通さないと気づかないっていうことも多々あるので、やっぱり常にフルテストを早く通し続けるっていう環境を作んないといけないよね、というような話で、まあテストをするのをやめるのは論外だし、テストが終わるまで愚直に待つのは全然解決になってないと。
00：15：00
　で、proveには-j（ハイフンジェイ）ってオプションがあるんですけど、ちょっと深遠な理由でこれを使えないと。ちょっと使うとfailするっていうもがあるので、これを使うとちょっと大幅に改修しなきゃいけないねという事案が1件あったのと、それ以外の高速化で事前起動できるものは競合を起こさないものの対応を進めたりというのはちょいちょいやってはいます。ただ、さっきもお話した通りテストの数が多いので、やっぱり単独での高速化っていうのはどっかで限界を迎えるでしょうというような話になりました。
　なので、スケールするやり方に変わらないといけないと。ということで、高速化にあたってこんな感じで要件を決めました。
　まず、すでに書いてあるテストっていうのは触らなくていい。書かれたテストっていうのはそのまま置くと。既存のCIサーバーはそのまま使いたいと。Ukigumoは、Ukigumo::Serverはは引き続き使いたいと。なので、これはちょっと〓総枠組みの施策検索〓という話をした。
　であと、やっぱりちゃんと、先ほど話したんですけど、スケールすること。例えばテスト数が10倍になったとか、平行する開発数が10倍になったとか、そんな状況になっても吸収できる枠組みであること。というのが要件でした。
　そこで、分散実行をさせましょうというアイデアを立ててですね、複数のサーバーに分散でリクエストを投げて、その実行結果を返して集計する、というのができればノードを追加してスケールするみたいな枠組みに落とせそうだなという話でした。
　で、サーバーの追加とかメンテが簡単にできるように、簡単なコンフィグファイルだけでサーバーノードを管理すればいいよね、みたいな感じに理想をしようとしてました。
　あと、複数のサーバーにリクエストを投げるので、ネットワークの理由とか何らかの理由でテストファイル、1台のサーバーがフェイルしたみたいなことがあるので、再実行というものをまずできるようにしようと。というのはSQLiteを実行済みのブランチなんかは保存するようにしちゃって、その辺は簡単にコントロールできるようにしましょうと。というので実装してます、しました。
（分散実行の仕組み）
　で、簡単にいうとこういうことですね、という話です。サーバーノードの中でブランチ、そのプッシュされたブランチの中に入っている実行対象テストのリストを取ってきて、クラスターの台数分で等分割します。その等分割したテストの一覧を各サーバーに投げて実行した結果を返してもらって集計して、Ukigumoとそれ以外というようなレポート名になってますけど、そういったファイルをポストするっていうような仕組みです。
　で、それぞれ簡単な、よく知られたCPANモジュールだけで、この辺は書けるので、実際にやってることはすごく簡単です。例えばテストのピックアップとシャッフルというのはFile::FindとList::MoreUtilsで普通に分割して、クラスター名をキーにした配列とかにぶっ込んでおけば割り当てができますねと。で、クラスターノードでの実行命令とか結果受取、これはシリアルにやっちゃうとまずいので、Parallel::ForkManagerを使えばできますので。で、結果のパースとかはPerlの得意なところなので言わずもがなと。で、Ukigumoへのポストは先ほどのコードの通り、LWPで書いてポストで、それで終わらしてしまえと、いうような感じです。
　で、これがサーバー側なんですけど、今度実行するクラスター側って何やってるかというともっと簡単で、TAP::Harness::runtestsにテスト一覧を渡して実行するだけです。
（コードサンプルで解説）
　ということで、ちょっとコードサンプルで解説します。
　あーこれ見えないな。見えないですけど、単にハッシュに突っ込んでるPerlのファイルです。こういうのを●します。
　これは。
　実行することは単純で、Parallel::ForkManagerでコンフィグに書かれている台数分プロセスを上げて、それぞれforで回して、〓オウテンセン〓sshでテストリストを投げて、先にgit fetchさせて最終的に実行した結果を受け取ると。
00：19：55
　で、最近のParallel::ForkManagerだと、run\_on\_finish、どこだ。というmethodで、ここだ。ここの、フィニッシュしたときに任意のcode refみたいなものを渡して、処理に渡してデータを集計できるので、子プロセスでsshを投げて、クラスターノードの実行した結果を受け取ったら、親プロセスに渡すときにこういうやり方をすると簡単にのれるので、バージョンいくつだったか忘れましたけど、新しいParallel::ForkManagerを入れると、とっても捗ります。
　時間が…。こんなもんか。
　パースするところは単純に、全部のテストがどのくらい走ったかと、どのくらいフェイルしたかしか計測はしてなくて、単純に集積〓機能〓になっているわけです。
　これがクラスターノードで実行しているランチャーなんですけど、ホント簡単ですねと。オプションで、今はわかんないですけど、デリミタでリストを渡してますけど、そいつをスクリプトしてruntestsに渡すだけですから。こっち側ではシャッフルはする必要なくて、というのはマスターの側でもうシャッフルはしてあるので、ここは受け取って実行するだけでいいというようなものです。
（再実行）
　で、これが実行するところなんですけど、次、再実行の話で。再実行するときはマスターノードで再実行用のWeb appを起動しておいて、リクエストをかけたらその実施状況を保存しているLQLiteからそのブランチを削除するだけみたいな、簡単なアプリケーションを起動して待つ。
　あと、これはkanさん書いてくれたのかな、ですけど、クローム拡張でUkigumoのサーバーにボタンを追加するみたいな対応で、再実行が簡単にできるようにしています。画面の感じは〓こんな感じで〓、この、「リトライ」っていうボタンですね。これを追加するような、そんな感じの対応をしています。なので、このフェイルしてるっていう内容が、単純にテストだけで〓内容〓だったら直すべきなんですけど、特定のサーバーだけ応答がないとかっていう結果が出てる場合は再実行ができるようになってます。
（動かすサーバー）
　で、動かしているサーバーなんですけど、社内にこんな感じで余った自作サーバーのパーツを寄せ集めて作ってます。なので、ご家庭に余っているあり合わせのパーツがあればそれでも作れます。というのはうちの事情なんですけど、まあAWSでいいんじゃないですかね、と思います。必要な時間だけサーバーの動作をスタートして、要らなくなったら、就業時間が終わったらストップする、そんな感じの運用でいいのかなと思います。
（結果）
　これでやった結果どうなったかなんですけど、16ノード動かして180秒で返ってくるようになりました。単純に割った数だけで済まないのは、各テストのイニシャライズに関してはやっぱり等しくかかってくるので、そういったところに関してはやっぱり単純には、割った数くらいには速くはならないなという結果でした。
　とは言え、2,000秒が180秒くらいで返ってくるようになったので、結構ライフチェンジングだったなあという感じです。
　で、これは簡単でコンフィグに素直にサーバーを足せばスケールすると。要はサーバーをセットアップして単独でメイクテストが通ればクラスターに投入してオッケーですね。これはPuppetでどうにかなります。
　で、再実行ボタンが気軽に押せる。というのは、180秒で結果返ってくるので何らか失敗あってもすぐポチっと押せば、もう1回チェックをして結果が見れると。
　手元で2,000秒待つよりはプッシュしたほうが速い。なので、ほかの人の開発アクティビティが見えやすくなるっていう副次的な効果がありました。これが嬉しい誤算ですね。
　手元でやるよりプッシュしたほうが速いっていうことになると、とりあえずみんなブランチ作ってプッシュしようぜ、みたいな感じになる。そういう文化になるように仕向けることができるということなんです。
　なので、チームメンバーのコードを早めに見てツッコンだりツッコミもらったり、というようなツッコミビリティが上がって、結果、開発品質、速度はもちろん、フルテスト早く終わるんで上がるんですけど、品質もまあ向上を図れるかなと、そんな感じでした。なので、高速なテストというのは開発文化を変えるんだなあとみたいなことを感じました。

（改善構想）
　とは言え、まだまだ改善する余地はありまして、テストが通せなかったサーバーはそもそもスキップしてどこかでリトライ自動でやろうよという話はまあ考えてて。それ以外にproveのjオプション使えるようにテストを直して、ちゃんと(CPU)コアは使い切りましょうという話とか。それがどうしてもできなかったら、LXCとかVMでもいいんですけど、1ノードあたりの実行環境をできるだけ増やしてあげるということをすれば、もっと速くなるかなというふうには思ってます。
　なので、わりと一般的なCPANモジュールの組み合わせでフルテストを分散実行して高速化する枠組みというのを実装できて、今運用してます。
　で、個別的なやり方というのは全然すごくやるべきだと思うし、みんなsoh335さんのスライド読んだほうがいいと思うんですけど、それだけでは足りなくなって来るっていうのは、テスト書きまくってたらいつか来るので、そういうときにはこのスケールするようなやり方に、わりと簡単に移行できるのでおススメです。
（おわりに）

![](http://30d.jp/img/yapcasia/6/703_large.jpg "(c) Japan Perl Association")

　で、おわりになんですけど、FreakOutはPerlアプリケーションで書いてるんですけど、そのテスト方法とかCIとか、フルテスト実行のスケールアウト手法について紹介しました。で、結構地味な手法だと思うんですけど、テストを高速に回し続ける環境がこれでできたので、リリース速度と品質の両面をカバーすることっていうのは、これでひとつできているんだなあと考えています。
　で、今回の内容は来月発売のWeb+DB PRESS、Perl Hackers Hubに一部掲載されます。最初のおさらいはすっ飛ばしたんですけど、それ以外のテストクラスターのほうに関しても、サンプルコード、gihyo.jpで公開されます。なので、ぜひお買い求めください。
　おわりにもうひとつ。テストはどんどん書こうということは訴えたいなと。こんなことをnaoyaさんがお話ししてましたけど、「テストを頻繁にせよ。コンパイル時にはテストを局所化して1日に最低1度はすべてのテストを実行せよ」とマーチン・ファウラーが言っていると書いてありますけど、もうプッシュごとにテストしようよと。どんどん書いて、ということですね。高速なテストっていうのは開発文化を変える。なので皆さんどんどんテストを書きましょう。
　ということで、FreakOutでは課題の認識／解決に技術で向き合い、アウトプットしていくエンジニアを募集しているので、ご関心のある方はこちらをご覧ください。ないし、FreakOut Tシャツは、昨日みんな着てたから今日着てないのかな。まあなので、手近なFreakOut社員を見つけてお話しを聞くなど、ありだと思います。なので、ぜひぜひよろしくお願いいたします。ということで私のトークは終わりにさせていただきます。ありがとうございました（拍手）。
（質問）
司会：何か質問ある方、いらっしゃいますか。あと12分ぐらいあるのでぜひ。
会場：はーい、質問、はい、ありまーす。
司会：どなたですか。あ、2階。
会場：直接いいですか。Jenkinsだと、分散実行がnativeでサポートされていると思うんですけれども、そっちじゃなくてUkigumoの〓改造〓のほうに選んだという理由があれば、聞かせていただきたい。
久森：まあPerlで完結するからですかね。あとJenkinsというよりは、最初にUkigumoでcycle作るっていうのを作ってたんで、Jenkinsのその分散実行が調べる前に、これでできちゃわねっていうんで書いたというのもあります。
会場：そっちのほうがコストが安い？
久森：うーん、そんなに時間かからずに実装できたので、まあ、いいかなと。あと、Jenkinsの作法を知っているみたいな人があんまり社内にいなかったというのもあります。なので、社内にJenkinsおじさんがいたらそっちでやってもいいのかなというふうには思います。
司会：ほかに何か質問ある方いらっしゃいますか。
久森：どんどん質問していただいて。
質問者：ほかの方もTL上で話してたんですけど、テストケースが増えていくとどうしても重複しているテストとか、そういうのが増えてって、そういうものを減らすことによってテスト時間を減らしたいみたいなところで、結構そういうなんか方法論が、まだあんまりないのかなという感じがしてるんですけど、その辺りに関して何か考えてることとかありますか。
久森：コード書いてる人が気づいたベースで削っていくっていう感じなのかなっていう。ちょっと今タイムライン読み始めたので。
質問者：でもそういう話です。
久森：重複したテストは、気づいたら削るぐらいかなというのが、今のところ。
質問者：まあそうですよね。ありがとうございます。
久森：逆に良いソリューションがあれば、ぜひ登壇して発表していただきたいです。その他、いらっしゃれば。
久森：今日はどうもありがとうございました。2日間お疲れ様でした。
（拍手）


